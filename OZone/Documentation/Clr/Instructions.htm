<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
		<title></title>
	</head>
	<body>
	
		<h2>
			CIL Instruction Set
		</h2>
		<div align="center">
			<table>
				<tr>
					<td>
						Name</td>
					<td>
						<b>
						Opcode</b>
					</td>
					<td>
						<b>
						Instruction</b>
					</td>
					<td>
						<b>
						Description</b>
					</td>
				</tr>
				<tr>
					<td>
						AddValues</td>
					<td>
						58
					</td>
					<td>
						add
					</td>
					<td>
						Add two values, returning a new value.
					</td>
				</tr>
				<tr>
					<td>
						AddSignedIntegerValuesAndCheckOverflow</td>
					<td>
						D6
					</td>
					<td>
						add.ovf
					</td>
					<td>
						Add signed integer values with overflow check.
					</td>
				</tr>
				<tr>
					<td>
						AddUnsignedIntegerValuesAndCheckOverflow</td>
					<td>
						D7
					</td>
					<td>
						add.ovf.un
					</td>
					<td>
						Add unsigned integer values with overflow check.
					</td>
				</tr>
				<tr>
					<td>
						AndIntegerValues</td>
					<td>
						5F
					</td>
					<td>
						and
					</td>
					<td>
						Bitwise AND of two integral values, returns an integral value.
					</td>
				</tr>
				<tr>
					<td>
						GetArgumentListHandle</td>
					<td>
						FE 00
					</td>
					<td>
						arglist
					</td>
					<td>
						Return argument list handle for the current method.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfEqual32</td>
					<td>
						3B
					</td>
					<td>
						beq &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if equal.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfEqual8</td>
					<td>
						2E
					</td>
					<td>
						beq.s&lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if equal, short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanOrEqualTo32</td>
					<td>
						3C
					</td>
					<td>
						bge &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if greater than or equal to.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanOrEqualTo8</td>
					<td>
						2F
					</td>
					<td>
						bge.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if greater than or equal to, short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanOrEqualToUnsigned32</td>
					<td>
						41
					</td>
					<td>
						bge.un &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if greater than or equal to (unsigned or unordered).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanOrEqualToUnsigned8</td>
					<td>
						34
					</td>
					<td>
						bge.un.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if greater than or equal to (unsigned or unordered), short form
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThan32</td>
					<td>
						3D
					</td>
					<td>
						bgt &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if greater than.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThan8</td>
					<td>
						30
					</td>
					<td>
						bgt.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if greater than, short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanUnsigned32</td>
					<td>
						42
					</td>
					<td>
						bgt.un &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if greater than (unsigned or unordered).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfGreaterThanUnsigned8</td>
					<td>
						35
					</td>
					<td>
						bgt.un.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if greater than (unsigned or unordered), short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanOrEqualTo32</td>
					<td>
						3E
					</td>
					<td>
						ble &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if less than or equal to.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanOrEqualTo8</td>
					<td>
						31
					</td>
					<td>
						ble.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if less than or equal to, short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanOrEqualToUnsigned32</td>
					<td>
						43
					</td>
					<td>
						ble.un &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if less than or equal to (unsigned or unordered).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanOrEqualToUnsigned8</td>
					<td>
						36
					</td>
					<td>
						ble.un.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if less than or equal to (unsigned or unordered), short form
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThan32</td>
					<td>
						3F
					</td>
					<td>
						blt &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if less than.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThan8</td>
					<td>
						32
					</td>
					<td>
						blt.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if less than, short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanUnsigned32</td>
					<td>
						44
					</td>
					<td>
						blt.un &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if less than (unsigned or unordered).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfLessThanUnsigned8</td>
					<td>
						37
					</td>
					<td>
						blt.un.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if less than (unsigned or unordered), short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNotEqual32</td>
					<td>
						40
					</td>
					<td>
						bne.un &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if unequal or unordered.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNotEqual8</td>
					<td>
						33
					</td>
					<td>
						bne.un.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if unequal or unordered, short form.
					</td>
				</tr>
				<tr>
					<td>
						BoxValue</td>
					<td>
						8C
					</td>
					<td>
						box &lt;typeTok&gt;
					</td>
					<td>
						Convert a boxable value to its boxed form
					</td>
				</tr>
				<tr>
					<td>
						JumpTo32</td>
					<td>
						38
					</td>
					<td>
						br &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target.
					</td>
				</tr>
				<tr>
					<td>
						JumpTo8</td>
					<td>
						2B
					</td>
					<td>
						br.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target, short form.
					</td>
				</tr>
				<tr>
					<td>
						Break</td>
					<td>
						01
					</td>
					<td>
						break
					</td>
					<td>
						Inform a debugger that a breakpoint has been reached.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfFalse32</td>
					<td>
						39
					</td>
					<td>
						brfalse &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if value is zero (false).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfFalse8</td>
					<td>
						2C
					</td>
					<td>
						brfalse.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if value is zero (false), short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNotNull32</td>
					<td>
						3A
					</td>
					<td>
						brinst &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if value is a non-null object reference (alias for brtrue).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNotNull8</td>
					<td>
						2D
					</td>
					<td>
						brinst.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if value is a non-null object reference, short form (alias for brtrue.s).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNull32</td>
					<td>
						39
					</td>
					<td>
						brnull &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if value is null (alias for brfalse).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfNull8</td>
					<td>
						2C
					</td>
					<td>
						brnull &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if value is null (alias for brfalse.s), short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfTrue32</td>
					<td>
						3A
					</td>
					<td>
						brtrue &lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if value is non-zero (true).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfTrue8</td>
					<td>
						2D
					</td>
					<td>
						brtrue.s &lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if value is non-zero (true), short form.
					</td>
				</tr>
				<tr>
					<td>
						BranchIfZero32</td>
					<td>
						39
					</td>
					<td>
						brzero&lt;int32 (target)&gt;
					</td>
					<td>
						Branch to target if value is zero (alias for brfalse).
					</td>
				</tr>
				<tr>
					<td>
						BranchIfZero8</td>
					<td>
						2C
					</td>
					<td>
						brzero&lt;int8 (target)&gt;
					</td>
					<td>
						Branch to target if value is zero (alias for brfalse.s), short form.
					</td>
				</tr>
				<tr>
					<td>
						CallMethod</td>
					<td>
						28
					</td>
					<td>
						call &lt;method&gt;
					</td>
					<td>
						Call method described by method.
					</td>
				</tr>
				<tr>
					<td>
						CallSite</td>
					<td>
						29
					</td>
					<td>
						calli &lt;callsitedescr&gt;
					</td>
					<td>
						Call method indicated on the stack with arguments described by callsitedescr.
					</td>
				</tr>
				<tr>
					<td>
						CallObjectMethod</td>
					<td>
						6F
					</td>
					<td>
						callvirt &lt;method&gt;
					</td>
					<td>
						Call a method associated with an object.
					</td>
				</tr>
				<tr>
					<td>
						CastObject</td>
					<td>
						74
					</td>
					<td>
						castclass &lt;class&gt;
					</td>
					<td>
						Cast obj to class.
					</td>
				</tr>
				<tr>
					<td>
						PushEqual</td>
					<td>
						FE 01
					</td>
					<td>
						ceq
					</td>
					<td>
						Push 1 (of type int32) if value1 equals value2, else push 0.
					</td>
				</tr>
				<tr>
					<td>
						PushGreaterThan</td>
					<td>
						FE 02
					</td>
					<td>
						cgt
					</td>
					<td>
						Push 1 (of type int32) if value1 &gt; value2, else push 0.
					</td>
				</tr>
				<tr>
					<td>
						PushGreaterThanUnsigned</td>
					<td>
						FE 03
					</td>
					<td>
						cgt.un
					</td>
					<td>
						Push 1 (of type int32) if value1 &gt; value2, unsigned or unordered, else push 0.
					</td>
				</tr>
				<tr>
					<td>
						CheckFiniteNumber</td>
					<td>
						C3
					</td>
					<td>
						ckfinite
					</td>
					<td>
						Throw ArithmeticException if value is not a finite number.
					</td>
				</tr>
				<tr>
					<td>
						PushLessThan</td>
					<td>
						FE 04
					</td>
					<td>
						clt
					</td>
					<td>
						Push 1 (of type int32) if value1 &lt; value2, else push 0.
					</td>
				</tr>
				<tr>
					<td>
						PushLessThanUnordered</td>
					<td>
						FE 05
					</td>
					<td>
						clt.un
					</td>
					<td>
						Push 1 (of type int32) if value1 &lt; value2, unsigned or unordered, else push 0.
					</td>
				</tr>
				<tr>
					<td>
						CallVirtualMethodForType</td>
					<td>
						FE 16
					</td>
					<td>
						constrained. &lt;thisType&gt; [prefix]
					</td>
					<td>
						Call a virtual method on a type constrained to be type T
					</td>
				</tr>
				<tr>
					<td>
						ConvertToNativeInteger</td>
					<td>
						D3
					</td>
					<td>
						conv.i
					</td>
					<td>
						Convert to native int, pushing native int on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToByte</td>
					<td>
						67
					</td>
					<td>
						conv.i1
					</td>
					<td>
						Convert to int8, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToShort</td>
					<td>
						68
					</td>
					<td>
						conv.i2
					</td>
					<td>
						Convert to int16, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToInteger</td>
					<td>
						69
					</td>
					<td>
						conv.i4
					</td>
					<td>
						Convert to int32, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToLong</td>
					<td>
						6A
					</td>
					<td>
						conv.i8
					</td>
					<td>
						Convert to int64, pushing int64 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToNativeIntegerAndCheckOverflow</td>
					<td>
						D4
					</td>
					<td>
						conv.ovf.i
					</td>
					<td>
						Convert to a native int (on the stack as native int) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToNativeIntegerAndCheckOverflow</td>
					<td>
						8A
					</td>
					<td>
						conv.ovf.i.un
					</td>
					<td>
						Convert unsigned to a native int (on the stack as native int) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToByteAndCheckOverflow</td>
					<td>
						B3
					</td>
					<td>
						conv.ovf.i1
					</td>
					<td>
						Convert to an int8 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToByteAndCheckOverflow</td>
					<td>
						82
					</td>
					<td>
						conv.ovf.i1.un
					</td>
					<td>
						Convert unsigned to an int8 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToShortAndCheckOverflow</td>
					<td>
						B5
					</td>
					<td>
						conv.ovf.i2
					</td>
					<td>
						Convert to an int16 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToShortAndCheckOverflow</td>
					<td>
						83
					</td>
					<td>
						conv.ovf.i2.un
					</td>
					<td>
						Convert unsigned to an int16 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToIntegerAndCheckOverflow</td>
					<td>
						B7
					</td>
					<td>
						conv.ovf.i4
					</td>
					<td>
						Convert to an int32 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToIntegerAndCheckOverflow</td>
					<td>
						84
					</td>
					<td>
						conv.ovf.i4.un
					</td>
					<td>
						Convert unsigned to an int32 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToLongAndCheckOverflow</td>
					<td>
						B9
					</td>
					<td>
						conv.ovf.i8
					</td>
					<td>
						Convert to an int64 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToLongAndCheckOverflow</td>
					<td>
						85
					</td>
					<td>
						conv.ovf.i8.un
					</td>
					<td>
						Convert unsigned to an int64 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToNativeUnsignedIntegerAndCheckOverflow</td>
					<td>
						D5
					</td>
					<td>
						conv.ovf.u
					</td>
					<td>
						Convert to a native unsigned int (on the stack as native int) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToNativeUnsignedIntegerAndCheckOverflow</td>
					<td>
						8B
					</td>
					<td>
						conv.ovf.u.un
					</td>
					<td>
						Convert unsigned to a native unsigned int (on the stack as native int) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedByteAndCheckOverflow</td>
					<td>
						B4
					</td>
					<td>
						conv.ovf.u1
					</td>
					<td>
						Convert to an unsigned int8 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToUnsignedByteAndCheckOverflow</td>
					<td>
						86
					</td>
					<td>
						conv.ovf.u1.un
					</td>
					<td>
						Convert unsigned to an unsigned int8 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedShortAndCheckOverflow</td>
					<td>
						B6
					</td>
					<td>
						conv.ovf.u2
					</td>
					<td>
						Convert to an unsigned int16 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToUnsignedShortAndCheckOverflow</td>
					<td>
						87
					</td>
					<td>
						conv.ovf.u2.un
					</td>
					<td>
						Convert unsigned to an unsigned int16 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedIntegerAndCheckOverflow</td>
					<td>
						B8
					</td>
					<td>
						conv.ovf.u4
					</td>
					<td>
						Convert to an unsigned int32 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToUnsignedIntegerAndCheckOverflow</td>
					<td>
						88
					</td>
					<td>
						conv.ovf.u4.un
					</td>
					<td>
						Convert unsigned to an unsigned int32 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedLongAndCheckOverflow</td>
					<td>
						BA
					</td>
					<td>
						conv.ovf.u8
					</td>
					<td>
						Convert to an unsigned int64 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToUnsignedLongAndCheckOverflow</td>
					<td>
						89
					</td>
					<td>
						conv.ovf.u8.un
					</td>
					<td>
						Convert unsigned to an unsigned int64 (on the stack as int32) and throw an exception on overflow.
					</td>
				</tr>
				<tr>
					<td>
						ConvertUnsignedToFloat</td>
					<td>
						76
					</td>
					<td>
						conv.r.un
					</td>
					<td>
						Convert unsigned integer to floating-point, pushing F on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToFloat</td>
					<td>
						6B
					</td>
					<td>
						conv.r4
					</td>
					<td>
						Convert to float32, pushing F on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToDouble</td>
					<td>
						6C
					</td>
					<td>
						conv.r8
					</td>
					<td>
						Convert to float64, pushing F on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToNativeUnsignedInteger</td>
					<td>
						E0
					</td>
					<td>
						conv.u
					</td>
					<td>
						Convert to native unsigned int, pushing native int on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedByte</td>
					<td>
						D2
					</td>
					<td>
						conv.u1
					</td>
					<td>
						Convert to unsigned int8, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedShort</td>
					<td>
						D1
					</td>
					<td>
						conv.u2
					</td>
					<td>
						Convert to unsigned int16, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedInteger</td>
					<td>
						6D
					</td>
					<td>
						conv.u4
					</td>
					<td>
						Convert to unsigned int32, pushing int32 on stack.
					</td>
				</tr>
				<tr>
					<td>
						ConvertToUnsignedLong</td>
					<td>
						6E
					</td>
					<td>
						conv.u8
					</td>
					<td>
						Convert to unsigned int64, pushing int64 on stack.
					</td>
				</tr>
				<tr>
					<td>
						CopyMemory</td>
					<td>
						FE 17
					</td>
					<td>
						cpblk
					</td>
					<td>
						Copy data from memory to memory.
					</td>
				</tr>
				<tr>
					<td>
						CopyValue</td>
					<td>
						70
					</td>
					<td>
						cpobj &lt;typeTok&gt;
					</td>
					<td>
						Copy a value type from src to dest.
					</td>
				</tr>
				<tr>
					<td>
						DivideValues</td>
					<td>
						5B
					</td>
					<td>
						div
					</td>
					<td>
						Divide two values to return a quotient or floating-point result.
					</td>
				</tr>
				<tr>
					<td>
						DivideUnsignedValues</td>
					<td>
						5C
					</td>
					<td>
						div.un
					</td>
					<td>
						Divide two values, unsigned, returning a quotient.
					</td>
				</tr>
				<tr>
					<td>
						DuplicateValue</td>
					<td>
						25
					</td>
					<td>
						dup
					</td>
					<td>
						Duplicate the value on the top of the stack.
					</td>
				</tr>
				<tr>
					<td>
						EndFault</td>
					<td>
						DC
					</td>
					<td>
						endfault
					</td>
					<td>
						End fault clause of an exception block.
					</td>
				</tr>
				<tr>
					<td>
						EndFilter</td>
					<td>
						FE 11
					</td>
					<td>
						endfilter
					</td>
					<td>
						End an exception handling filter clause.
					</td>
				</tr>
				<tr>
					<td>
						EndFinally</td>
					<td>
						DC
					</td>
					<td>
						endfinally
					</td>
					<td>
						End finally clause of an exception block.
					</td>
				</tr>
				<tr>
					<td>
						PushLongValue</td>
					<td>
						4C
					</td>
					<td>
						idind.u8
					</td>
					<td>
						Indirect load value of type unsigned int64 as int64 on the stack (alias for ldind.i8).
					</td>
				</tr>
				<tr>
					<td>
						SetMemory</td>
					<td>
						FE 18
					</td>
					<td>
						initblk
					</td>
					<td>
						Set all bytes in a block of memory to a given byte value.
					</td>
				</tr>
				<tr>
					<td>
						InitializeMemory</td>
					<td>
						FE 15
					</td>
					<td>
						initobj &lt;typeTok&gt;
					</td>
					<td>
						Initialize the value at address dest.
					</td>
				</tr>
				<tr>
					<td>
						GetObjectAsType</td>
					<td>
						75
					</td>
					<td>
						isinst &lt;class&gt;
					</td>
					<td>
						Test if obj is an instance of class, returning null or an instance of that class or interface.
					</td>
				</tr>
				<tr>
					<td>
						JumpToMethod</td>
					<td>
						27
					</td>
					<td>
						jmp &lt;method&gt;
					</td>
					<td>
						Exit current method and jump to the specified method.
					</td>
				</tr>
				<tr>
					<td>
						PushArgumentToStack16</td>
					<td>
						FE 09
					</td>
					<td>
						ldarg &lt;uint16 (num)&gt;
					</td>
					<td>
						Load argument numbered num onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushArgument0ToStack</td>
					<td>
						02
					</td>
					<td>
						ldarg.0
					</td>
					<td>
						Load argument 0 onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushArgument1ToStack</td>
					<td>
						03
					</td>
					<td>
						ldarg.1
					</td>
					<td>
						Load argument 1 onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushArgument2ToStack</td>
					<td>
						04
					</td>
					<td>
						ldarg.2
					</td>
					<td>
						Load argument 2 onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushArgument3ToStack</td>
					<td>
						05
					</td>
					<td>
						ldarg.3
					</td>
					<td>
						Load argument 3 onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushArgumentToStack8</td>
					<td>
						0E
					</td>
					<td>
						ldarg.s &lt;uin8 (num)&gt;
					</td>
					<td>
						Load argument numbered num onto the stack, short form.
					</td>
				</tr>
				<tr>
					<td>
						GetArgumentAddress16</td>
					<td>
						FE 0A
					</td>
					<td>
						ldarga &lt;uint16 (argNum)&gt;
					</td>
					<td>
						Fetch the address of argument argNum.
					</td>
				</tr>
				<tr>
					<td>
						GetArgumentAddress8</td>
					<td>
						0F
					</td>
					<td>
						ldarga.s &lt;uint8 (argNum)&gt;
					</td>
					<td>
						Fetch the address of argument argNum, short form.
					</td>
				</tr>
				<tr>
					<td>
						PushIntegerValueToStack</td>
					<td>
						20
					</td>
					<td>
						ldc.i4 &lt;int32 (num)&gt;
					</td>
					<td>
						Push num of type int32 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushZeroToStack32</td>
					<td>
						16
					</td>
					<td>
						ldc.i4.0
					</td>
					<td>
						Push 0 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushOneToStack32</td>
					<td>
						17
					</td>
					<td>
						ldc.i4.1
					</td>
					<td>
						Push 1 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushTwoToStack32</td>
					<td>
						18
					</td>
					<td>
						ldc.i4.2
					</td>
					<td>
						Push 2 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushThreeToStack32</td>
					<td>
						19
					</td>
					<td>
						ldc.i4.3
					</td>
					<td>
						Push 3 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushFourToStack32</td>
					<td>
						1A
					</td>
					<td>
						ldc.i4.4
					</td>
					<td>
						Push 4 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushFiveToStack32</td>
					<td>
						1B
					</td>
					<td>
						ldc.i4.5
					</td>
					<td>
						Push 5 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushSixToStack32</td>
					<td>
						1C
					</td>
					<td>
						ldc.i4.6
					</td>
					<td>
						Push 6 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushSevenToStack32</td>
					<td>
						1D
					</td>
					<td>
						ldc.i4.7
					</td>
					<td>
						Push 7 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushEightToStack32</td>
					<td>
						1E
					</td>
					<td>
						ldc.i4.8
					</td>
					<td>
						Push 8 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushNegativeOneToStack32</td>
					<td>
						15
					</td>
					<td>
						ldc.i4.m1
					</td>
					<td>
						Push -1 onto the stack as int32.
					</td>
				</tr>
				<tr>
					<td>
						PushIntegerNegativeOneToStack32</td>
					<td>
						15
					</td>
					<td>
						ldc.i4.M1
					</td>
					<td>
						Push -1 of type int32 onto the stack as int32 (alias for ldc.i4.m1).
					</td>
				</tr>
				<tr>
					<td>
						PushByteValueToStack32</td>
					<td>
						1F
					</td>
					<td>
						ldc.i4.s &lt;int8 (num)&gt;
					</td>
					<td>
						Push num onto the stack as int32, short form.
					</td>
				</tr>
				<tr>
					<td>
						PushLongValueToStack64</td>
					<td>
						21
					</td>
					<td>
						ldc.i8 &lt;int64 (num)&gt;
					</td>
					<td>
						Push num of type int64 onto the stack as int64.
					</td>
				</tr>
				<tr>
					<td>
						PushFloatValueToStack32</td>
					<td>
						22
					</td>
					<td>
						ldc.r4 &lt;float32 (num)&gt;
					</td>
					<td>
						Push num of type float32 onto the stack as F.
					</td>
				</tr>
				<tr>
					<td>
						PushDoubleValueToStack32</td>
					<td>
						23
					</td>
					<td>
						ldc.r8 &lt;float64 (num)&gt;
					</td>
					<td>
						Push num of type float64 onto the stack as F.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayItem</td>
					<td>
						A3
					</td>
					<td>
						ldelem &lt;typeTok&gt;
					</td>
					<td>
						Load the element at index onto the top of the stack.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayNativeInteger</td>
					<td>
						97
					</td>
					<td>
						ldelem.i
					</td>
					<td>
						Load the element with type native int at index onto the top of the stack as a native int.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayByte</td>
					<td>
						90
					</td>
					<td>
						ldelem.i1
					</td>
					<td>
						Load the element with type int8 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayShort</td>
					<td>
						92
					</td>
					<td>
						ldelem.i2
					</td>
					<td>
						Load the element with type int16 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayInteger</td>
					<td>
						94
					</td>
					<td>
						ldelem.i4
					</td>
					<td>
						Load the element with type int32 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayLong</td>
					<td>
						96
					</td>
					<td>
						ldelem.i8
					</td>
					<td>
						Load the element with type int64 at index onto the top of the stack as an int64.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayFloat</td>
					<td>
						98
					</td>
					<td>
						ldelem.r4
					</td>
					<td>
						Load the element with type float32 at index onto the top of the stack as an F
					</td>
				</tr>
				<tr>
					<td>
						GetArrayDouble</td>
					<td>
						99
					</td>
					<td>
						ldelem.r8
					</td>
					<td>
						Load the element with type float64 at index onto the top of the stack as an F.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayObject</td>
					<td>
						9A
					</td>
					<td>
						ldelem.ref
					</td>
					<td>
						Load the element at index onto the top of the stack as an O. The type
						<p>
							of the O is the same as the element type of the array pushed on the CIL stack.
						</p>
					</td>
				</tr>
				<tr>
					<td>
						GetArrayUnsignedByte</td>
					<td>
						91
					</td>
					<td>
						ldelem.u1
					</td>
					<td>
						Load the element with type unsigned int8 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayUnsignedShort</td>
					<td>
						93
					</td>
					<td>
						ldelem.u2
					</td>
					<td>
						Load the element with type unsigned int16 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayUnsignedInteger</td>
					<td>
						95
					</td>
					<td>
						ldelem.u4
					</td>
					<td>
						Load the element with type unsigned int32 at index onto the top of the stack as an int32.
					</td>
				</tr>
				<tr>
					<td>
						GetArrayUnsignedLong</td>
					<td>
						96
					</td>
					<td>
						ldelem.u8
					</td>
					<td>
						Load the element with type unsigned int64 at index onto the top of the stack as an int64 (alias for ldelem.i8).
					</td>
				</tr>
				<tr>
					<td>
						GetArrayItemAddress</td>
					<td>
						8F
					</td>
					<td>
						ldelema &lt;class&gt;
					</td>
					<td>
						Load the address of element at index onto the top of the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushFieldValueToStack</td>
					<td>
						7B
					</td>
					<td>
						ldfld &lt;field&gt;
					</td>
					<td>
						Push the value of field of object (or value type) obj, onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushFieldAddressToStack</td>
					<td>
						7C
					</td>
					<td>
						ldflda &lt;field&gt;
					</td>
					<td>
						Push the address of field of object obj on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushMethodPointerToStack</td>
					<td>
						FE 06
					</td>
					<td>
						ldftn &lt;method&gt;
					</td>
					<td>
						Push a pointer to a method referenced by method, on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushNativeIntegerToStack</td>
					<td>
						4D
					</td>
					<td>
						ldind.i
					</td>
					<td>
						Indirect load value of type native int as native int on the stack
					</td>
				</tr>
				<tr>
					<td>
						PushByteToStack32</td>
					<td>
						46
					</td>
					<td>
						ldind.i1
					</td>
					<td>
						Indirect load value of type int8 as int32 on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushShortToStack32</td>
					<td>
						48
					</td>
					<td>
						ldind.i2
					</td>
					<td>
						Indirect load value of type int16 as int32 on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushIntegerToStack32</td>
					<td>
						4A
					</td>
					<td>
						ldind.i4
					</td>
					<td>
						Indirect load value of type int32 as int32 on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushLongToStack64</td>
					<td>
						4C
					</td>
					<td>
						ldind.i8
					</td>
					<td>
						Indirect load value of type int64 as int64 on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushFloatToStack32</td>
					<td>
						4E
					</td>
					<td>
						ldind.r4
					</td>
					<td>
						Indirect load value of type float32 as F on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushDoubleToStack64</td>
					<td>
						4F
					</td>
					<td>
						ldind.r8
					</td>
					<td>
						Indirect load value of type float64 as F on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushObjectToStack</td>
					<td>
						50
					</td>
					<td>
						ldind.ref
					</td>
					<td>
						Indirect load value of type object ref as O on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushUnsignedByteToStack32</td>
					<td>
						47
					</td>
					<td>
						ldind.u1
					</td>
					<td>
						Indirect load value of type unsigned int8 as int32 on the stack
					</td>
				</tr>
				<tr>
					<td>
						PushUnsignedShortToStack32</td>
					<td>
						49
					</td>
					<td>
						ldind.u2
					</td>
					<td>
						Indirect load value of type unsigned int16 as int32 on the stack
					</td>
				</tr>
				<tr>
					<td>
						PushUnsignedIntegerToStack32</td>
					<td>
						4B
					</td>
					<td>
						ldind.u4
					</td>
					<td>
						Indirect load value of type unsigned int32 as int32 on the stack
					</td>
				</tr>
				<tr>
					<td>
						GetArrayLength</td>
					<td>
						8E
					</td>
					<td>
						ldlen
					</td>
					<td>
						Push the length (of type native unsigned int) of array on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariableToStack16</td>
					<td>
						FE 0C
					</td>
					<td>
						ldloc &lt;uint16 (indx)&gt;
					</td>
					<td>
						Load local variable of index indx onto stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariable0ToStack</td>
					<td>
						06
					</td>
					<td>
						ldloc.0
					</td>
					<td>
						Load local variable 0 onto stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariable1ToStack</td>
					<td>
						07
					</td>
					<td>
						ldloc.1
					</td>
					<td>
						Load local variable 1 onto stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariable2ToStack</td>
					<td>
						08
					</td>
					<td>
						ldloc.2
					</td>
					<td>
						Load local variable 2 onto stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariable3ToStack</td>
					<td>
						09
					</td>
					<td>
						ldloc.3
					</td>
					<td>
						Load local variable 3 onto stack.
					</td>
				</tr>
				<tr>
					<td>
						PushVariableToStack8</td>
					<td>
						11
					</td>
					<td>
						ldloc.s &lt;uint8 (indx)&gt;
					</td>
					<td>
						Load local variable of index indx onto stack, short form.
					</td>
				</tr>
				<tr>
					<td>
						PushVariableAddressToStack16</td>
					<td>
						FE 0D
					</td>
					<td>
						ldloca &lt;uint16 (indx)&gt;
					</td>
					<td>
						Load address of local variable with index indx.
					</td>
				</tr>
				<tr>
					<td>
						PushVariableAddressToStack8</td>
					<td>
						12
					</td>
					<td>
						ldloca.s &lt;uint8 (indx)&gt;
					</td>
					<td>
						Load address of local variable with index indx, short form.
					</td>
				</tr>
				<tr>
					<td>
						PushNullToStack</td>
					<td>
						14
					</td>
					<td>
						ldnull
					</td>
					<td>
						Push a null reference on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushMemoryValueToStack</td>
					<td>
						71
					</td>
					<td>
						ldobj &lt;typeTok&gt;
					</td>
					<td>
						Copy the value stored at address src to the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushFieldValueToStack</td>
					<td>
						7E
					</td>
					<td>
						ldsfld &lt;field&gt;
					</td>
					<td>
						Push the value of field on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushFieldAddressToStack</td>
					<td>
						7F
					</td>
					<td>
						ldsflda &lt;field&gt;
					</td>
					<td>
						Push the address of the static field, field, on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PushStringToStack</td>
					<td>
						72
					</td>
					<td>
						ldstr &lt;string&gt;
					</td>
					<td>
						Push a string object for the literal string.
					</td>
				</tr>
				<tr>
					<td>
						GetRuntimeMetadata</td>
					<td>
						D0
					</td>
					<td>
						ldtoken &lt;token&gt;
					</td>
					<td>
						Convert metadata token to its runtime representation.
					</td>
				</tr>
				<tr>
					<td>
						PushVirtualAddressToStack</td>
					<td>
						FE 07
					</td>
					<td>
						ldvirtftn &lt;method&gt;
					</td>
					<td>
						Push address of virtual method method on the stack.
					</td>
				</tr>
				<tr>
					<td>
						LeaveProtectedCode32</td>
					<td>
						DD
					</td>
					<td>
						leave &lt;int32 (target)&gt;
					</td>
					<td>
						Exit a protected region of code.
					</td>
				</tr>
				<tr>
					<td>
						LeaveProtectedCode8</td>
					<td>
						DE
					</td>
					<td>
						leave.s &lt;int8 (target)&gt;
					</td>
					<td>
						Exit a protected region of code, short form.
					</td>
				</tr>
				<tr>
					<td>
						AllocateLocalMemory</td>
					<td>
						FE 0F
					</td>
					<td>
						localloc
					</td>
					<td>
						Allocate space from the local memory pool.
					</td>
				</tr>
				<tr>
					<td>
						PushTypedReference</td>
					<td>
						C6
					</td>
					<td>
						mkrefany &lt;class&gt;
					</td>
					<td>
						Push a typed reference to ptr of type class onto the stack.
					</td>
				</tr>
				<tr>
					<td>
						MultiplyValues</td>
					<td>
						5A
					</td>
					<td>
						mul
					</td>
					<td>
						Multiply values.
					</td>
				</tr>
				<tr>
					<td>
						MultiplySignedIntegerValues</td>
					<td>
						D8
					</td>
					<td>
						mul.ovf.&lt;type&gt;
					</td>
					<td>
						Multiply signed integer values. Signed result shall fit in same size
					</td>
				</tr>
				<tr>
					<td>
						MultiplyUnsignedIntegerValues</td>
					<td>
						D9
					</td>
					<td>
						mul.ovf.un
					</td>
					<td>
						Multiply unsigned integer values. Unsigned result shall fit in same size
					</td>
				</tr>
				<tr>
					<td>
						NegateValue</td>
					<td>
						65
					</td>
					<td>
						neg
					</td>
					<td>
						Negate value.
					</td>
				</tr>
				<tr>
					<td>
						CreateArray</td>
					<td>
						8D
					</td>
					<td>
						newarr &lt;etype&gt;
					</td>
					<td>
						Create a new array with elements of type etype.
					</td>
				</tr>
				<tr>
					<td>
						CreateObject</td>
					<td>
						73
					</td>
					<td>
						newobj &lt;ctor&gt;
					</td>
					<td>
						Allocate an uninitialized object or value type and call ctor.
					</td>
				</tr>
				<tr>
					<td>
						SkipCheck</td>
					<td>
						FE 19
					</td>
					<td>
						no. { typecheck, rangecheck, nullcheck } [prefix]
					</td>
					<td>
						The specified fault check(s) normally performed
						<p>
							as part of the execution of the subsequent instruction can/shall be skipped.
						</p>
					</td>
				</tr>
				<tr>
					<td>
						NoOperation</td>
					<td>
						00
					</td>
					<td>
						nop
					</td>
					<td>
						Do nothing.
					</td>
				</tr>
				<tr>
					<td>
						NotValues</td>
					<td>
						66
					</td>
					<td>
						not
					</td>
					<td>
						Bitwise complement.
					</td>
				</tr>
				<tr>
					<td>
						OrValues32</td>
					<td>
						60
					</td>
					<td>
						or
					</td>
					<td>
						Bitwise OR of two integer values, returns an integer.
					</td>
				</tr>
				<tr>
					<td>
						PullValueFromStack</td>
					<td>
						26
					</td>
					<td>
						pop
					</td>
					<td>
						Pop value from the stack.
					</td>
				</tr>
				<tr>
					<td>
						ReadOnly</td>
					<td>
						FE 1E
					</td>
					<td>
						readonly. [prefix]
					</td>
					<td>
						Specify that the subsequent array address operation performs no
						<p>
							type check at runtime, and that it returns a controlled-mutability managed pointer
						</p>
					</td>
				</tr>
				<tr>
					<td>
						PushTypeIDToStack</td>
					<td>
						FE 1D
					</td>
					<td>
						refanytype
					</td>
					<td>
						Push the type token stored in a typed reference.
					</td>
				</tr>
				<tr>
					<td>
						PushAddressToStack</td>
					<td>
						C2
					</td>
					<td>
						refanyval &lt;type&gt;
					</td>
					<td>
						Push the address stored in a typed reference.
					</td>
				</tr>
				<tr>
					<td>
						DivideValuesAndGetRemainder</td>
					<td>
						5D
					</td>
					<td>
						rem
					</td>
					<td>
						Remainder when dividing one value by another.
					</td>
				</tr>
				<tr>
					<td>
						DivideUnsignedValuesAndGetRemainder</td>
					<td>
						5E
					</td>
					<td>
						rem.un
					</td>
					<td>
						Remainder when dividing one unsigned value by another.
					</td>
				</tr>
				<tr>
					<td>
						Return</td>
					<td>
						2A
					</td>
					<td>
						ret
					</td>
					<td>
						Return from method, possibly with a value.
					</td>
				</tr>
				<tr>
					<td>
						RethrowException</td>
					<td>
						FE 1A
					</td>
					<td>
						rethrow
					</td>
					<td>
						Rethrow the current exception.
					</td>
				</tr>
				<tr>
					<td>
						ShiftIntegerLeft</td>
					<td>
						62
					</td>
					<td>
						shl
					</td>
					<td>
						Shift an integer left (shifting in zeros), return an integer.
					</td>
				</tr>
				<tr>
					<td>
						ShiftIntegerRight</td>
					<td>
						63
					</td>
					<td>
						shr
					</td>
					<td>
						Shift an integer right (shift in sign), return an integer.
					</td>
				</tr>
				<tr>
					<td>
						ShiftUnsignedIntegerRight</td>
					<td>
						64
					</td>
					<td>
						shr.un
					</td>
					<td>
						Shift an integer right (shift in zero), return an integer.
					</td>
				</tr>
				<tr>
					<td>
						GetTypeSize</td>
					<td>
						FE 1C
					</td>
					<td>
						sizeof &lt;typeTok&gt;
					</td>
					<td>
						Push the size, in bytes, of a type as an unsigned int32.
					</td>
				</tr>
				<tr>
					<td>
						PullArgumentFromStack16</td>
					<td>
						FE 0B
					</td>
					<td>
						starg &lt;uint16 (num)&gt;
					</td>
					<td>
						Store value to the argument numbered num.
					</td>
				</tr>
				<tr>
					<td>
						PullArgumentFromStack8</td>
					<td>
						10
					</td>
					<td>
						starg.s &lt;uint8 (num)&gt;
					</td>
					<td>
						Store value to the argument numbered num, short form.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayItemFromStack</td>
					<td>
						A4
					</td>
					<td>
						stelem &lt;typeTok&gt;
					</td>
					<td>
						Replace array element at index with the value on the stack
					</td>
				</tr>
				<tr>
					<td>
						PullArrayNativeIntegerFromStack</td>
					<td>
						9B
					</td>
					<td>
						stelem.i
					</td>
					<td>
						Replace array element at index with the i value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayByteFromStack</td>
					<td>
						9C
					</td>
					<td>
						stelem.i1
					</td>
					<td>
						Replace array element at index with the int8 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayShortFromStack</td>
					<td>
						9D
					</td>
					<td>
						stelem.i2
					</td>
					<td>
						Replace array element at index with the int16 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayIntegerFromStack</td>
					<td>
						9E
					</td>
					<td>
						stelem.i4
					</td>
					<td>
						Replace array element at index with the int32 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayLongFromStack</td>
					<td>
						9F
					</td>
					<td>
						stelem.i8
					</td>
					<td>
						Replace array element at index with the int64 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayFloatFromStack</td>
					<td>
						A0
					</td>
					<td>
						stelem.r4
					</td>
					<td>
						Replace array element at index with the float32 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayDoubleFromStack</td>
					<td>
						A1
					</td>
					<td>
						stelem.r8
					</td>
					<td>
						Replace array element at index with the float64 value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						PullArrayReferenceFromStack</td>
					<td>
						A2
					</td>
					<td>
						stelem.ref
					</td>
					<td>
						Replace array element at index with the ref value on the stack.
					</td>
				</tr>
				<tr>
					<td>
						SetFieldValue</td>
					<td>
						7D
					</td>
					<td>
						stfld &lt;field&gt;
					</td>
					<td>
						Replace the value of field of the object obj with value.
					</td>
				</tr>
				<tr>
					<td>
						SetNativeIntegerAtAddress</td>
					<td>
						DF
					</td>
					<td>
						stind.i
					</td>
					<td>
						Store value of type native int into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetByteAtAddress</td>
					<td>
						52
					</td>
					<td>
						stind.i1
					</td>
					<td>
						Store value of type int8 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetShortAtAddress</td>
					<td>
						53
					</td>
					<td>
						stind.i2
					</td>
					<td>
						Store value of type int16 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetIntegerAtAddress</td>
					<td>
						54
					</td>
					<td>
						stind.i4
					</td>
					<td>
						Store value of type int32 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetLongAtAddress</td>
					<td>
						55
					</td>
					<td>
						stind.i8
					</td>
					<td>
						Store value of type int64 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetFloatAtAddress</td>
					<td>
						56
					</td>
					<td>
						stind.r4
					</td>
					<td>
						Store value of type float32 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetDoubleAtAddress</td>
					<td>
						57
					</td>
					<td>
						stind.r8
					</td>
					<td>
						Store value of type float64 into memory at address
					</td>
				</tr>
				<tr>
					<td>
						SetReferenceAtAddress</td>
					<td>
						51
					</td>
					<td>
						stind.ref
					</td>
					<td>
						Store value of type object ref (type O) into memory at address
					</td>
				</tr>
				<tr>
					<td>
						PullVariableFromStack16</td>
					<td>
						FE 0E
					</td>
					<td>
						stloc &lt;uint16 (indx)&gt;
					</td>
					<td>
						Pop a value from stack into local variable indx.
					</td>
				</tr>
				<tr>
					<td>
						PullVariable0FromStack</td>
					<td>
						0A
					</td>
					<td>
						stloc.0
					</td>
					<td>
						Pop a value from stack into local variable 0.
					</td>
				</tr>
				<tr>
					<td>
						PullVariable1FromStack</td>
					<td>
						0B
					</td>
					<td>
						stloc.1
					</td>
					<td>
						Pop a value from stack into local variable 1.
					</td>
				</tr>
				<tr>
					<td>
						PullVariable2FromStack</td>
					<td>
						0C
					</td>
					<td>
						stloc.2
					</td>
					<td>
						Pop a value from stack into local variable 2.
					</td>
				</tr>
				<tr>
					<td>
						PullVariable3FromStack</td>
					<td>
						0D
					</td>
					<td>
						stloc.3
					</td>
					<td>
						Pop a value from stack into local variable 3.
					</td>
				</tr>
				<tr>
					<td>
						PullVariableFromStack8</td>
					<td>
						13
					</td>
					<td>
						stloc.s &lt;uint8 (indx)&gt;
					</td>
					<td>
						Pop a value from stack into local variable indx, short form.
					</td>
				</tr>
				<tr>
					<td>
						SetTypeAtAddress</td>
					<td>
						81
					</td>
					<td>
						stobj &lt;typeTok&gt;
					</td>
					<td>
						Store a value of type typeTok at an address.
					</td>
				</tr>
				<tr>
					<td>
						SetFieldValue</td>
					<td>
						80
					</td>
					<td>
						stsfld &lt;field&gt;
					</td>
					<td>
						Replace the value of field with val.
					</td>
				</tr>
				<tr>
					<td>
						SubtractValues</td>
					<td>
						59
					</td>
					<td>
						sub
					</td>
					<td>
						Subtract value2 from value1, returning a new value.
					</td>
				</tr>
				<tr>
					<td>
						SubtractNativeIntegers</td>
					<td>
						DA
					</td>
					<td>
						sub.ovf
					</td>
					<td>
						Subtract native int from a native int. Signed result shall fit in same size
					</td>
				</tr>
				<tr>
					<td>
						SubtractUnsignedNativeIntegers</td>
					<td>
						DB
					</td>
					<td>
						sub.ovf.un
					</td>
					<td>
						Subtract native unsigned int from a native unsigned int. Unsigned result shall fit in same size.
					</td>
				</tr>
				<tr>
					<td>
						Switch</td>
					<td>
						45
					</td>
					<td>
						switch &lt;uint32, int32,int32 (t1..tN)&gt;
					</td>
					<td>
						Jump to one of n values.
					</td>
				</tr>
				<tr>
					<td>
						EndMethod</td>
					<td>
						FE 14
					</td>
					<td>
						tail. [prefix]
					</td>
					<td>
						Subsequent call terminates current method
					</td>
				</tr>
				<tr>
					<td>
						ThrowException</td>
					<td>
						7A
					</td>
					<td>
						throw
					</td>
					<td>
						Throw an exception.
					</td>
				</tr>
				<tr>
					<td>
						Unaligned</td>
					<td>
						FE 12
					</td>
					<td>
						unaligned. (alignment) [prefix]
					</td>
					<td>
						Subsequent pointer instruction might be unaligned.
					</td>
				</tr>
				<tr>
					<td>
						Unbox</td>
					<td>
						79
					</td>
					<td>
						unbox &lt;valuetype&gt;
					</td>
					<td>
						Extract a value-type from obj, its boxed representation.
					</td>
				</tr>
				<tr>
					<td>
						UnboxAny</td>
					<td>
						A5
					</td>
					<td>
						unbox.any &lt;typeTok&gt;
					</td>
					<td>
						Extract a value-type from obj, its boxed representation
					</td>
				</tr>
				<tr>
					<td>
						Volatile</td>
					<td>
						FE 13
					</td>
					<td>
						volatile. [prefix]
					</td>
					<td>
						Subsequent pointer reference is volatile.
					</td>
				</tr>
				<tr>
					<td>
						ExclusiveOrValues</td>
					<td>
						61
					</td>
					<td>
						xor
					</td>
					<td>
						Bitwise XOR of integer values, returns an integer.
					</td>
				</tr>
			</table>
		</div>
	
	</body>
</html>