WAVEDEV.rar es1371.cpp .dp-cpp .datatypes { color: #2E8B57; font-weight: bold; } 
www.pudn.com > WAVEDEV.rar > es1371.cpp, change:2004-07-01,size:42889b
 
   


 



  //   
  // Copyright (c) Microsoft Corporation.  All rights reserved.   
  //   
  //   
  // Use of this source code is subject to the terms of the Microsoft end-user   

  // license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.   
  // If you did not accept the terms of the EULA, you are not authorized to use  
   
  // this source code. For a copy of the EULA, please see the LICENSE.RTF on 
  your   
  // install media.   
  //   
  //   
  // Copyright 1998-2000 (c) Creative Labs, Malvern.  All rights reserved.   
  //   
  // $Workfile: es1371.cpp $      
  //   
     
  #include <windows.h>   
  #include <waveddsi.h>   
  #include <ceddk.h>   
  #include "es1371.h"   
     
  DWORD gIntrAudio;   
     
  #define STR_MODULENAME "CES1371: "   
     
  typedef struct   
  {   
      CES1371           * pHardware;   
      BOOLEAN             fRead;   
      ULONG               ulPage;   
      ULONG               ulIOAddress;   
      PULONG              pulData;   
  }   
  SYNCIOCONTEXT, *PSYNCIOCONTEXT;   
     
  static   
  NTSTATUS   
  SynchronizedPagedIO   
  (   
      IN      PINTERRUPTSYNC  InterruptSync,   
      IN      PVOID           syncIOContext   
  );   
     
  // {{{ constructor/destructor   
     
  CES1371::CES1371 (void)   
  {   
      m_pInterruptSync = (IInterruptSync_WinCeStub*)new 
  IInterruptSync_WinCeStub;   
      m_fIsMapped = FALSE;   
      m_refcount = 0;   
      m_ulPowerState = 0;   
  }   
     
     
  CES1371::~CES1371 ()   
  {   
      //invalidate our member variables   
      if (m_fIsMapped) {   
          MmUnmapIoSpace(m_pPciAddr, ES1371_IO_SPACE_SIZE);   
          m_fIsMapped = FALSE;   
      }   
      m_pPciAddr = 0;   
  }   
     
  LONG CES1371::AddRef (void)   
  {   
      return InterlockedIncrement (&m_refcount);   
  }   
     
  LONG CES1371::Release (void)   
  { LONG newcount;   
     
      newcount = InterlockedDecrement (&m_refcount);   
      if (newcount == 0) {    
          delete this;   
      }   
      return newcount;   
  }   
     
     
     
  // }}}   
     
  // {{{ Init   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: CES1371::MapHardware   
  //   
  //  Description: Maps port address, assigns SysIntr   
  //   
  //  Parameters: none   
  //   
  //  Returns: BOOL   
  //      TRUE if device was mapped properly   
  //      FALSE if device could not be mapped    
  //   
  //  Note:    
  //   
  //--------------------------------------------------------------------------   

  BOOL CES1371::MapHardware (ULONG ulSysIntr, ULONG ulPciAddr, ULONG 
  ulPciLength, ULONG ulDeviceID, ULONG ulRevisionID)   
  {   
      PHYSICAL_ADDRESS    PortAddress;   
      PHYSICAL_ADDRESS    MappedAddress;   
     
      //initialize our member variables   
      m_pPciAddr = (PUCHAR)ulPciAddr;   
         
      //   
      // Configure IO address   
      //   
      {   
          //   
          // Translate address   
          //   
          DWORD inIoSpace = 1;    // io space       
          PortAddress.LowPart  = (DWORD)m_pPciAddr;   
          PortAddress.HighPart = 0;    
             
          if (!HalTranslateBusAddress(PCIBus, 0, PortAddress, &inIoSpace, 
  &MappedAddress)) {   
              DEBUGMSG(1, (L"CES1371::MapHardware - failed 
  HalTranslateBusAddress\r\n"));   
              return FALSE;   
          }   
             
     
          if (!inIoSpace) {   
              // Get virtual address   
              if ((m_pPciAddr = (PUCHAR)MmMapIoSpace(MappedAddress, ulPciLength, 
  FALSE)) == NULL) {   
                  DEBUGMSG(1, (TEXT("CES1371::MapHardware -  Error mapping I/O 
  Ports.\r\n")));   
                  return FALSE;   
              }   
              DEBUGMSG(1, (L"CES1371::MapHardware - MappedAddress = 0x%X, 
  m_pPciAddr = 0x%X\r\n", MappedAddress.LowPart, m_pPciAddr));   
          } else {   
              m_pPciAddr = (PUCHAR)MappedAddress.LowPart;   
          }   
      }   
     
      DEBUGMSG(1, (L"CES1371::MapHardware2 - MappedAddress = 0x%X, m_pPciAddr = 
  0x%X\r\n", MappedAddress.LowPart, m_pPciAddr));   
     
      //   
      // Configure Interrupt    
      //   
      gIntrAudio = ulSysIntr;   
     
      // record the Device ID and Revision ID for posterity.   
      m_usDid = (USHORT)ulDeviceID;   
      m_ucRevision = (UCHAR)ulRevisionID;   
     
      //call our initialization functions   
      InitHardware();   
     
      return TRUE;   
  }      
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: CES1371::InitHardware   
  //   
  //  Description: intitializes the 1371 hardware   
  //   
  //  Parameters: none   
  //   
  //  Returns: void   
  //   
  //  Note:    
  //   
  //--------------------------------------------------------------------------   

  void CES1371::InitHardware()   
  {   
      UCHAR  bReg = 0x00;   
      USHORT wReg = 0x0000;   
      ULONG  i;   
     
      // if we have a 5880 then take the AC97 codec out of reset   
      if ( (m_usDid == ES5880_PCI_DEVID)                          ||   
           ((m_usDid == ES1371_PCI_DEVID) && (m_ucRevision == 7)) ||    
           ((m_usDid == ES1371_PCI_DEVID) && (m_ucRevision >= 9))   
         )   
      {   
          // write the es137x AC97 reset bit   
          bReg = 0x20;   
          HwRegRMW( ES1371_bINTSUMM_OFF, 0x20, bReg );   
     
          // wait around a long time for the codec to come out of reset   
          // i.e. 20 msec or 200 * 100 nanosec   
  #ifdef UNDER_CE   
          Sleep(1);   
  #else   
          if ( KeGetCurrentIrql() == PASSIVE_LEVEL )   
          {   
              LARGE_INTEGER liTimeout =   
                     RtlConvertLongToLargeInteger( -200 );    
     
              KeDelayExecutionThread( KernelMode, FALSE, &liTimeout );   
          }   
          else // wait around the old fashioned way by polling   
          {   
              ULONG ulPollCount;   
              UCHAR ucDummyRead;   
     
              for ( ulPollCount = 0; ulPollCount < 110000; ulPollCount++ )   
              {   
                  ucDummyRead = READ_PORT_UCHAR( m_pPciAddr );   
              }   
          }   
  #endif   
     
          // The 5880 has a mux to configure the line in/rear spkr out   
          // jack to the appropriate function.  In the basic driver,   
          // we'll assume it'll always be a line in function (set   
          // GPIO2 bit to zero).   
          HwRegRMW( ES1371_bGPIO_OFF, (UCHAR)0x04, (UCHAR) 0x00);   
     
      }   
     
      // write bogus values into the DRegs so the initial writes take   
      for ( i=0; i<12; i++)   
        m_ulDRegs[i] = 0xffffffff;   
         
      /*  
       *put the HW into a happy state  
       */     
      InitSRC( TRUE );   
         
      /* setup the MISCCTRL reg */   
      bReg =   
          ES1371_MISCCTL_PDLEV_D0   
          & ~ES1371_MISCCTL_CCBINTRM_EN;   
     
      HwRegRMW( ES1371_bMISCCTL_OFF, 0xff, bReg );   
         
      /* setup the DEVCTRL reg */   
      /* enable UART, XTAL clock and PCI clock */   
      bReg =   
           ES1371_DEVCTL_UART_EN    
          & ~ES1371_DEVCTL_XTALCLK_DS   
          & ~ES1371_DEVCTL_PCICLK_DS;   
         
      HwRegRMW( ES1371_bDEVCTL_OFF, 0xff, bReg );   
     
      /* setup the JOYCTRL reg */   
      bReg = 0;   
      HwRegRMW( ES1371_bJOYCTL_OFF, 0xff, bReg );   
         
      /* disable the NMI */   
      bReg = 0x00;   
      HwRegRMW( ES1371_bNMIENA_OFF, 0xff, bReg );   
         
      /* clear the NMI status register */   
      wReg = 0x0000;   
      HwRegRMW( ES1371_wNMISTAT_OFF, 0xffff, wReg );   
         
      /* clear the Serial Control register */   
      bReg = 0x00;   
      HwRegRMW( ES1371_bSERCTL_OFF, 0xff, bReg );   
         
      // initialize Codec   
      InitCodec();   
     
      // initialize UART   
      m_ulUARTState = 0;   
     
      //   
      // Cycle the power state to get registers image, etc.   
      //   
      //SetPowerState(1); // Turn off to set register arrays    
      //SetPowerState(0);   
     
      return;   
  }   
     
  // }}}   
     
  // {{{ SRCInit   
     
  void CES1371::InitSRC( BOOLEAN fEnable )   
  {   
      USHORT     i;   
      ULONG      ulHardwareWrite;   
     
      /* must poll before writes to DISABLE or PAUSE the SRCIO register */   
      SRCPollIOReg ();   
      /* disable SRC for init */   
      ulHardwareWrite = SRC_DISABLE;   
      HwRegRMW( ES1371_dSRCIO_OFF, 0xffffffff, ulHardwareWrite );    
  //    WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), SRC_DISABLE); 
    
     
      /* clear the SRC RAM */   
      for( i = 0; i < 0x80; ++i )   
          SRCRegWrite(i, 0 );   
     
      SRCRegWrite(SRC_DAC0_BASE + SRC_TRUNC_N_OFF, 16 << 4);   
      SRCRegWrite(SRC_DAC0_BASE + SRC_INT_REGS_OFF, 16 << 10);   
      SRCRegWrite(SRC_DAC1_BASE + SRC_TRUNC_N_OFF, 16 << 4);   
      SRCRegWrite(SRC_DAC1_BASE + SRC_INT_REGS_OFF, 16 << 10);   
      SRCRegWrite(SRC_ADC_BASE + SRC_TRUNC_N_OFF, 16 << 4);   
      SRCRegWrite(SRC_ADC_BASE + SRC_INT_REGS_OFF, 16 << 10);   
      SRCRegWrite(SRC_DAC0_VOL_L, 1 << 12);   
      SRCRegWrite(SRC_DAC0_VOL_R, 1 << 12);   
      SRCRegWrite(SRC_DAC1_VOL_L, 1 << 12);   
      SRCRegWrite(SRC_DAC1_VOL_R, 1 << 12);   
      SRCRegWrite(SRC_ADC_VOL_L, 1 << 12);   
      SRCRegWrite(SRC_ADC_VOL_R, 1 << 12);   
     
      /* default some rates */   
      SRCSetRate(ES1371_DAC0, 22050);   
      SRCSetRate(ES1371_DAC1, 22050);   
      SRCSetRate(ES1371_ADC, 22050);   
     
  #if (DBG)   
      USHORT usSRCdata[8];   
      USHORT j;   
      /* dump the SRC ram */   
      DEBUGMSG( 1, (TEXT("es1371 dump SRC ram\r")));   
     
      for ( i = 0; i < 16; i++ )   
      {   
        for ( j = 0; j < 8; j++)   
        {   
            usSRCdata[j] = SRCRegRead( i*8 + j );     
        }   
     
        DEBUGMSG( 1, (TEXT("%02x %04x %04x %04x %04x %04x %04x %04x %04x\r"), 
  i*8,   
                                        usSRCdata[0],usSRCdata[1],   
                                        usSRCdata[2],usSRCdata[3],   
                                        usSRCdata[4],usSRCdata[5],   
                                        usSRCdata[6],usSRCdata[7]));   
      }   
  #endif   
     
      if ( fEnable )   
      {   
          /* now enable the whole deal */   
          SRCPollIOReg ();   
          ulHardwareWrite = 0L;   
          HwRegRMW( ES1371_dSRCIO_OFF, 0xffffffff, ulHardwareWrite );    
      }   
     
      return;   
  }   
     
  // }}}   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: HwPagedIOWrite   
  //   
  //  Description: Does a MP-safe write to the indirect registers   
  //   
  //  Parameters: UCHAR Page : the memory page to set   
  //              PULONG pAddr : the IO address to write   
  //              ULONG ulData : the data to write   
  //   
  //  Returns: NTSTATUS       
  //   
  //--------------------------------------------------------------------------   

  NTSTATUS   
  CES1371::HwPagedIOWrite( UCHAR Page, ULONG pAddr, ULONG ulData )   
  {   
      SYNCIOCONTEXT context;   
      ULONG ulWriteData;   
     
      NTSTATUS ntStatus = STATUS_SUCCESS;   
     
      if ( 0 == m_ulPowerState )   
      {   
          // normal power state - go read the hardware   
          ulWriteData = ulData;   
     
          context.pHardware = this;   
          context.fRead = FALSE;   
          context.ulPage = ULONG( Page );   
          context.ulIOAddress = pAddr;   
          context.pulData = &ulWriteData;   
     
          ntStatus = m_pInterruptSync->   
                       
  CallSynchronizedRoutine(SynchronizedPagedIO,PVOID(&context));   
      }   
      else   
      {   
          // power down state - can't write hardware write the saved setting   
          m_ulIRegsPMContext[ (ULONG(Page) * 4) + ( (pAddr - 0x30) / 4 ) ] = 
  ulData;   
      }   
     
      return ntStatus;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: HwPagedIORead   
  //   
  //  Description: Sets the current page of indirect registers   
  //   
  //  Parameters: UCHAR Page : the memory page to set   
  //              PULONG pAddr : the IO address to read   
  //   
  //  Returns: data read      
  //   
  //--------------------------------------------------------------------------   

  ULONG   
  CES1371::HwPagedIORead( UCHAR Page, ULONG pAddr )   
  {   
      SYNCIOCONTEXT context;   
      ULONG ulReadData;   
     
      NTSTATUS ntStatus = STATUS_SUCCESS;   
     
      if ( 0 == m_ulPowerState )   
      {   
          // normal power state - go read the hardware   
          context.pHardware = this;   
          context.fRead = TRUE;   
          context.ulPage = ULONG( Page );   
          context.ulIOAddress = pAddr;   
          context.pulData = &ulReadData;   
     
          ntStatus = m_pInterruptSync->   
                       
  CallSynchronizedRoutine(SynchronizedPagedIO,PVOID(&context));   
      }   
      else   
      {   
          // power down state - can't read hardware get the saved setting   
          ulReadData = m_ulIRegsPMContext[ (ULONG(Page) * 4) + ( (pAddr - 0x30) 
  / 4 ) ];   
      }   
     
      return ulReadData;   
  }   
     
  // {{{ HwRegRMW   
  /* -----------------------------------------------------------------------  /  

    
      Routine:  HwRegRMW  
    
      Purpose:  The routine is used to access a Concert chip register via  
                its shadowed value.  This routine is required to provide  
                exclusion (synchronization) to the register.  
    
                This routine should be run from the KeSynchronizeExecution  
                call,  forceing this routine to execute at our devices  
                DIRQL.  It also acquires the spin lock, providing exclusion.  
    
                The current value in the shadow ram is read, ANDed with  
                the mask and ORed with the bits.  
    
    
      Inputs:  
    
      Output:   None  
    
      Errors:   None  
    
  /  ----------------------------------------------------------------------- */  
   
  UCHAR   
  CES1371::HwRegRMW (  UCHAR Reg, UCHAR bBitMask, UCHAR bSetBits )   
  {   
     UCHAR bNewValue;   
     UCHAR *puc_DRegs = (UCHAR *)m_ulDRegs;   
     
     // are we setting the whole data space?   
     if ( 0x00 == bBitMask )   
     {   
         return ( *(puc_DRegs + Reg) );   
     }   
     else if ( 0xff == bBitMask )   
     {   
         bNewValue = bSetBits;   
     }   
     else   
     {   
         // read original value,    
         // zero out bits of interest,    
         // set proper bits to one    
         if ( (0xff != *(puc_DRegs + Reg)) || ( m_ulPowerState > 0 ) )   
             bNewValue = *(puc_DRegs + Reg);   
         else   
             bNewValue = READ_PORT_UCHAR (m_pPciAddr + Reg);   
         bNewValue &= ~bBitMask;   
         bNewValue |= (bSetBits & bBitMask);   
     }   
     // write new value to hardware   
     if ( 0 == m_ulPowerState )   
         WRITE_PORT_UCHAR ( m_pPciAddr + Reg, bNewValue);   
     
     // save the value for the future   
     *(puc_DRegs + Reg) = bNewValue;   
     
     return bNewValue;   
     
  }  // end of function: hw_reg_rmw_char   
     
  // }}}   
     
  // {{{ HwRegRMW   
  USHORT   
  CES1371::HwRegRMW ( UCHAR Reg, USHORT wBitMask, USHORT wSetBits )   
  {   
     USHORT wNewValue;   
     USHORT *pus_DRegs = (USHORT *)m_ulDRegs;   
        
     // are we setting the whole data space?   
     if ( 0x0000 == wBitMask )   
     {   
         return ( *(pus_DRegs + Reg/2) );   
     }   
     else if ( 0xffff == wBitMask )   
     {   
         wNewValue = wSetBits;   
     }   
     else   
     {   
         // read original value,    
         // zero out bits of interest,    
         // set proper bits to one   
         if ( (0xffff != *(pus_DRegs + (Reg/2))) || ( m_ulPowerState > 0 ) )   
             wNewValue = *(pus_DRegs + (Reg/2));   
         else   
             wNewValue = READ_PORT_USHORT ( (PUSHORT)(m_pPciAddr + Reg) );   
         wNewValue &= ~wBitMask;   
         wNewValue |= (wSetBits & wBitMask);   
     }   
          
     /* write new value to hardware */   
     if ( 0 == m_ulPowerState )   
         WRITE_PORT_USHORT ( (PUSHORT)(m_pPciAddr + Reg), wNewValue );   
        
     // save the value for the future   
     *(pus_DRegs + (Reg/2)) = wNewValue;   
     
     return wNewValue;   
       
  }  /* end of function: hw_reg_rmw_short */   
     
  // }}}   
     
  // {{{ HwRegRMW   
  ULONG   
  CES1371::HwRegRMW ( UCHAR Reg, ULONG dwBitMask, ULONG dwSetBits )   
  {   
     ULONG dwNewValue;   
     
     // are we setting the whole data space?   
     if ( 0x00000000 == dwBitMask )   
     {   
         return ( m_ulDRegs[Reg/4] );   
     }   
     else if ( 0xffffffff == dwBitMask )   
     {   
         dwNewValue = dwSetBits;   
     }   
     else   
     {   
         // read original value,    
         // zero out bits of interest,    
         // set proper bits to one    
         if ( (0xffffffff != m_ulDRegs[Reg/4]) || ( m_ulPowerState > 0 ) )   
             dwNewValue = m_ulDRegs[Reg/4];   
         else   
             dwNewValue = READ_PORT_ULONG ( (PULONG)(m_pPciAddr + Reg) );   
     
         dwNewValue &= ~dwBitMask;   
         dwNewValue |= (dwSetBits & dwBitMask);   
     }   
     
     /* write new value to hardware */   
     if ( 0 == m_ulPowerState )   
         WRITE_PORT_ULONG ( (PULONG)(m_pPciAddr + Reg), dwNewValue );   
     
     // save the value for the future   
     m_ulDRegs[Reg/4] = dwNewValue;   
     
     return dwNewValue;   
     
  }  /* end of function: hw_reg_rmw_long */   
     
  // }}}   
     
  // {{{ SRCRegRead   
     
  USHORT   
  CES1371::SRCRegRead( USHORT reg )   
  {   
     /* LOCAL DATA */   
     ULONG    dtemp;   
     /* END LOCAL DATA */   
     
     // Is the device powered down?   
     if ( m_ulPowerState > 0 )   
          return m_usSRCRegsPMContext[ reg ];   
     
     /* wait for ready */   
     dtemp = SRCPollIOReg ();   
         
     /* assert a read request */   
     WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF),   
                      (dtemp & SRC_CTLMASK) | (ULONG(reg) << 25) );   
     
     /* wait for the data */   
     dtemp = SRCPollIOReg ();   
     return (USHORT) dtemp;   
  }   
     
  // }}}   
     
  void    
  CES1371::SRCRegWrite(USHORT reg, USHORT val)   
  {   
      ULONG    i, dtemp;   
     
      // Is the device powered down?   
      if ( m_ulPowerState > 0 )   
      {   
          m_usSRCRegsPMContext[ reg ] = val;   
          return;   
      }   
     
      /* wait for ready */   
      dtemp = SRCPollIOReg ();   
     
      /* assert the write request */   
      i = (dtemp & SRC_CTLMASK) | SRC_WENABLE |   
              ( (ULONG)reg << 25 ) | val;   
     
      /* write the value */   
      WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), i);   
     
  #ifdef DBG   
      {   
        USHORT us;   
        us = SRCRegRead ( reg );   
        if ( us != val )   
          _DbgPrintF( DEBUGLVL_TERSE, ("[SRCRegWrite] FAILED reg %02x wrote %04x 
  read %04x", reg, val, us));   
      }   
  #endif   
     
      return;   
  }   
     
  // }}}   
     
     
  void   
  CES1371::SRCSetRate( UCHAR ucDMAChannel, USHORT wSampleRate )   
  {   
      ULONG    i, freq, dtemp;   
      USHORT   N, truncM, truncStart, wtemp;   
     
      // Is the device powered down?   
      if ( m_ulPowerState > 0 )   
          return;   
     
      switch ( ucDMAChannel )   
      {   
        case ES1371_DAC0:   
          // freeze the channel   
          for( i = 0; i < SRC_IOPOLL_COUNT; ++i )   
              if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) 
  & SRC_BUSY) )   
                  break;   
     
          dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF));   
          WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF),   
                  (dtemp & SRC_CTLMASK) | SRC_DAC0FREEZE);   
     
          // calculate new frequency and write it   
          // preserve accum    
          freq = ((ULONG) wSampleRate << 16) / 3000U;   
          SRCRegWrite( SRC_DAC0_BASE + SRC_INT_REGS_OFF,    
                       (SRCRegRead( SRC_DAC0_BASE + SRC_INT_REGS_OFF ) & 
  0x00ffU) |   
                         ((USHORT) (freq >> 6) & 0xfc00));   
          SRCRegWrite( SRC_DAC0_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1);  
   
     
          // un-freeze the channel   
          for( i = 0; i < SRC_IOPOLL_COUNT; ++i )   
              if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) 
  & SRC_BUSY) )   
                  break;   
          dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF));   
          WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF),   
                  (dtemp & SRC_CTLMASK) & (~SRC_DAC0FREEZE) );   
          break;   
     
        case ES1371_DAC1:   
          // freeze the channel   
          for( i = 0; i < SRC_IOPOLL_COUNT; ++i )   
              if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) 
  & SRC_BUSY) )   
                  break;   
     
          dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF));   
          WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF),   
                  (dtemp & SRC_CTLMASK) | SRC_DAC1FREEZE);   
     
          // calculate new frequency and write it   
          // preserve accum    
          freq = ((ULONG) wSampleRate << 16) / 3000U;   
          SRCRegWrite( SRC_DAC1_BASE + SRC_INT_REGS_OFF,    
                       (SRCRegRead( SRC_DAC1_BASE + SRC_INT_REGS_OFF ) & 
  0x00ffU) |   
                         ((USHORT) (freq >> 6) & 0xfc00));   
          SRCRegWrite( SRC_DAC1_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1);  
   
     
          // un-freeze the channel   
          for( i = 0; i < SRC_IOPOLL_COUNT; ++i )   
              if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) 
  & SRC_BUSY) )   
                  break;   
          dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF));   
          WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF),   
                  (dtemp & SRC_CTLMASK) & (~SRC_DAC1FREEZE) );   
          break;   
     
        case ES1371_ADC:   
          // derive oversample ratio   
          N = wSampleRate/3000U;   
          if( N == 15 || N == 13 || N == 11 || N == 9 )   
              --N;   
     
          // truncate the filter and write n/trunc_start   
          truncM = (21*N - 1) | 1;   
          if( wSampleRate >= 24000U )   
          {   
              if( truncM > 239 )   
                  truncM = 239;   
              truncStart = (239 - truncM) >> 1;   
                 
              SRCRegWrite( SRC_ADC_BASE + SRC_TRUNC_N_OFF,   
                           (truncStart << 9) | (N << 4));   
          }   
          else   
          {   
              if( truncM > 119 )   
                  truncM = 119;   
              truncStart = (119 - truncM) >> 1;   
     
              SRCRegWrite( SRC_ADC_BASE + SRC_TRUNC_N_OFF,   
                      0x8000U | (truncStart << 9) | (N << 4));   
          }   
     
          /* calculate new frequency and write it - preserve accum */   
          freq = ((48000UL << 16) / wSampleRate) * N;   
          wtemp = SRCRegRead( SRC_ADC_BASE + SRC_INT_REGS_OFF );   
          SRCRegWrite( SRC_ADC_BASE + SRC_INT_REGS_OFF,   
                       (wtemp & 0x00ff) | ((USHORT) (freq >> 6) & 0xfc00));   
          SRCRegWrite( SRC_ADC_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1);   

     
          SRCRegWrite( SRC_ADC_VOL_L, N << 8);   
          SRCRegWrite( SRC_ADC_VOL_R, N << 8);   
          break;   
      }   
     
      return;   
  }   
     
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: SRCWaitForFrame1   
  //   
  //  Description: code that polls a value in the SRC converter so that we know  
   
  //               when it is safe to write.   
  //   
  //  Parameters:  PFRAME_CONTEXT   
  //   
  //  Returns: always succeeds   
  //   
  //  Note: Apparently, we can't do CODEC writes when the sync pulse is high.   
  //        Luckily, there are some debug things in the SRC that let us know   
  //        when sync pulse is low. This needs to be synched with the ISR so   
  //        we don't get interrupted and lose track of where we are.   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::SRCWaitForFrame1 ( )   
  {   
      while( !((READ_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & 
  0x00070000UL) ==   
            0x00010000UL) )   
  //<mod:ce> KeStallExecutionProcessor(1);   
     
      return;   
  }   
     
  // }}}   
        
  // {{{ SRCPollIOReg   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: SRCPollIOReg   
  //   
  //  Description:   
  //   
  //  Parameters:    
  //   
  //  Returns:       
  //   
  //  Note: This function must be called prior to any   
  //        writes to the Disable/Pause bits   
  //   
  //--------------------------------------------------------------------------   

  ULONG   
  CES1371::SRCPollIOReg ()   
  {   
    int i;   
    ULONG dw=0;   
     
    for (i=0; i<SRC_IOPOLL_COUNT; ++i)   
    {   
          if (!((dw = READ_PORT_ULONG ((PULONG)(m_pPciAddr+ES1371_dSRCIO_OFF))) 
  & SRC_BUSY) )   
            break;   
     
  //<mod:ce> KeStallExecutionProcessor (1);   
    }   
     
  #ifdef DBG   
    if (i == SRC_IOPOLL_COUNT)   
          _DbgPrintF( DEBUGLVL_TERSE, ("[SRCPollIOReg] timeout %x", dw));   
  #endif   
     
    return dw;   
  }   
     
  // }}}   
         
  //--------------------------------------------------------------------------   

  //   
  //  Name: InitDMAChannel   
  //   
  //  Description: Intialize all the things about a DMA channel   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to init   
  //              ULONG ulPhysDMAAddr : Physical address of the DMA buffer   
  //                                    in memory   
  //              USHORT usBufferSize : Number of bytes in a DMA buffer   
  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::InitDMAChannel( UCHAR ucDMAChannel,   
                           ULONG ulPhysDMAAddr,   
                           ULONG ulBufferSize )   
  {   
    ULONG ulFrameCount = 0;   
     
    m_dmachannel[ucDMAChannel].ulPhysDMAAddr = ulPhysDMAAddr;   
    m_dmachannel[ucDMAChannel].ulDMABufSize  = ulBufferSize;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // Set up the physical DMA buffer address   
        HwPagedIOWrite( ES1371_DAC0CTL_PAGE, ES1371_dDAC0PADDR_OFF, 
  ulPhysDMAAddr);     
        // Clear out the Frame count register   
        HwPagedIOWrite( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF, ulFrameCount);  
     
        break;   
     
      case ES1371_DAC1 :   
        // Set up the physical DMA buffer address   
        HwPagedIOWrite( ES1371_DAC1CTL_PAGE, ES1371_dDAC1PADDR_OFF, 
  ulPhysDMAAddr);     
        // Clear out the Frame count register   
        HwPagedIOWrite( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF, ulFrameCount);  
     
        break;   
     
      case ES1371_ADC :   
        // Set up the physical DMA buffer address   
        HwPagedIOWrite( ES1371_ADCCTL_PAGE, ES1371_dADCPADDR_OFF, 
  ulPhysDMAAddr);     
        // Clear out the Frame count register   
        HwPagedIOWrite( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF, ulFrameCount);    
   
        break;   
    }   
    return ;   
  }     
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: SetDMAChannelFormat   
  //   
  //  Description: Set the Format of a particular DMA channel.   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to init   
  //              ULONG ulChannels   : Number of audio channels 1=mono 2=stereo  
   
  //              ULONG ul16Bit      : flag for sample size 0=8bit 1=16bit   
  //              ULONG ulSampleRate : actual number of samples/second.   
  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::SetDMAChannelFormat( UCHAR ucDMAChannel,   
                                ULONG ulChannels,   
                                ULONG ul16Bit,   
                                ULONG ulSampleRate )   
  {   
    UCHAR ucFormatBits;   
    UCHAR ucSkipCount;   
     
    // save off the info for power managment   
    m_dmachannel[ucDMAChannel].ulChannels   = ulChannels;   
    m_dmachannel[ucDMAChannel].ul16Bit      = ul16Bit;   
    m_dmachannel[ucDMAChannel].ulSampleRate = ulSampleRate;   
     
    // first set the new sample rate   
    SRCSetRate ( ucDMAChannel, (USHORT) ulSampleRate );   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // set format bits for DAC0 ...    
        ucFormatBits = 0x00;   
        if( 2 == ulChannels )   
            ucFormatBits |= ES1371_PCM_DAC0_STEREO ;   
        if( 1 == ul16Bit )   
            ucFormatBits |= ES1371_PCM_DAC0_16BIT ;   
     
        HwRegRMW( ES1371_bSERFMT_OFF,    
                  ES1371_PCM_DAC0_STEREO|ES1371_PCM_DAC0_16BIT,   
                  ucFormatBits );    
        break;   
     
      case ES1371_DAC1 :   
        // set format bits for DAC1 ...    
        ucFormatBits = 0x00;   
        if( 2 == ulChannels )   
            ucFormatBits |= ES1371_PCM_DAC1_STEREO ;   
        if( 1 == ul16Bit )   
        {   
            ucFormatBits |= ES1371_PCM_DAC1_16BIT ;   
            // set the SKIP register for proper playback   
            ucSkipCount = 0x10;   
            HwRegRMW( ES1371_bSKIPC_OFF, 0x18, ucSkipCount );    
        }   
        else   
        {   // set the SKIP register for proper playback   
            ucSkipCount = 0x08;   
            HwRegRMW( ES1371_bSKIPC_OFF, 0x18, ucSkipCount );    
        }   
     
        HwRegRMW( ES1371_bSERFMT_OFF,    
                  ES1371_PCM_DAC1_STEREO|ES1371_PCM_DAC1_16BIT,   
                  ucFormatBits );    
        break;   
     
      case ES1371_ADC :   
        // set format bits for ADC ...    
        ucFormatBits = 0x00;   
        if( 2 == ulChannels )   
            ucFormatBits |= ES1371_PCM_ADC_STEREO ;   
        if( 1 == ul16Bit )   
            ucFormatBits |= ES1371_PCM_ADC_16BIT ;   
      
        HwRegRMW( ES1371_bSERFMT_OFF,    
                  ES1371_PCM_ADC_STEREO|ES1371_PCM_ADC_16BIT,   
                  ucFormatBits );    
        break;   
    }   
    return ;     
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: SetDMAChannelBuffer   
  //   
  //  Description: Set the buffer sizes of a particular DMA channel.   
  //   
  //  Parameters: UCHAR ucDMAChannel    : Index of the DMA channel to init   
  //              ULONG ulBufferLength  : Size in bytes of the whole DMA buffer  
   
  //              ULONG ulSamplesPerInt : Count of samples before interrupting   

  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::SetDMAChannelBuffer( UCHAR ucDMAChannel,   
                                ULONG ulBufferLength,   
                                ULONG ulSamplesPerInt )   
  {   
    ULONG ulDesiredBufferSize =  m_dmachannel[ucDMAChannel].ulDMABufSize;   
    USHORT usInterruptCount = (USHORT) (ulSamplesPerInt - 1);   
     
    m_dmachannel[ucDMAChannel].ulBufferLength  = ulBufferLength;   
    m_dmachannel[ucDMAChannel].ulSamplesPerInt = ulSamplesPerInt;   
     
    // buffer can't be bigger than half the physical buffer   
    ulDesiredBufferSize = MIN( ulDesiredBufferSize, ulBufferLength ) ;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // set the DAC0 DWORD frame count   
        HwPagedIOWrite( ES1371_DAC0CTL_PAGE,    
                        ES1371_wDAC0FC_OFF,    
                        (ulDesiredBufferSize/4 - 1) & 0x0000ffff );     
     
        // Write DAC0 interrupt count - sample frames per half-buffer (n-1).   
        HwRegRMW( ES1371_wDAC0IC_OFF, 0xffff, usInterruptCount );   
  //      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wDAC0IC_OFF),   
  //                         (USHORT) (ulSamplesPerInt - 1) ) ;   
        break;   
     
      case ES1371_DAC1 :   
        // set the DAC1 DWORD frame count   
        HwPagedIOWrite( ES1371_DAC1CTL_PAGE,    
                        ES1371_wDAC1FC_OFF,    
                        (ulDesiredBufferSize/4 - 1) & 0x0000ffff );     
     
        // Write DAC1 interrupt count - sample frames per half-buffer (n-1).   
        HwRegRMW( ES1371_wDAC1IC_OFF, 0xffff, usInterruptCount );   
  //      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wDAC1IC_OFF),   
  //                         (USHORT) (ulSamplesPerInt - 1) ) ;   
        break;   
     
      case ES1371_ADC :   
        // set the ADC DWORD frame count   
        HwPagedIOWrite( ES1371_ADCCTL_PAGE,    
                        ES1371_wADCFC_OFF,    
                        (ulDesiredBufferSize/4 - 1) & 0x0000ffff );     
     
        // Write ADC interrupt count - sample frames per half-buffer (n-1).   
        HwRegRMW( ES1371_wADCIC_OFF, 0xffff, usInterruptCount );   
  //      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wADCIC_OFF),   
  //                         (USHORT) (ulSamplesPerInt - 1) ) ;   
        break;   
    }   
    return ;     
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: StartDMAChannel   
  //   
  //  Description: Start a particular DMA channel running.   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to start   
  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::StartDMAChannel( UCHAR ucDMAChannel )   
  {   
    UCHAR ucIOVal;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState )   
        {   
          // modify pause bit for DAC0   
          ucIOVal = 0;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC0PAUSE, ucIOVal );   
        }   
        else   
        {   
          // enable the DAC0 interrupt   
          ucIOVal = ES1371_SERCTL_DAC0IE;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC0IE,   
                    ucIOVal );    
     
          // start DAC0   
          ucIOVal = ES1371_DEVCTL_DAC0_EN;   
          HwRegRMW( ES1371_bDEVCTL_OFF,   
                    ES1371_DEVCTL_DAC0_EN,   
                    ucIOVal );    
        }   
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING;   
        break;   
     
      case ES1371_DAC1 :   
        if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState )   
        {   
          // modify pause bit for DAC1   
          ucIOVal = 0;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC1PAUSE, ucIOVal );   
        }   
        else   
        {   
          // enable the DAC1 interrupt   
          ucIOVal = ES1371_SERCTL_DAC1IE;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC1IE,   
                    ucIOVal );    
     
          // start DAC1   
          ucIOVal = ES1371_DEVCTL_DAC1_EN;   
          HwRegRMW( ES1371_bDEVCTL_OFF,   
                    ES1371_DEVCTL_DAC1_EN,   
                    ucIOVal );    
        }   
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING;   
        break;   
     
      case ES1371_ADC :   
        // enable the ADC interrupt   
        ucIOVal = ES1371_SERCTL_ADCIE;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_ADCIE,   
                  ucIOVal );    
     
        // start ADC   
        ucIOVal = ES1371_DEVCTL_ADC_EN;   
        HwRegRMW( ES1371_bDEVCTL_OFF,   
                  ES1371_DEVCTL_ADC_EN,   
                  ucIOVal );    
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING;   
        break;   
    }   
    return;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: StopDMAChannel   
  //   
  //  Description: Stop a particular DMA channel.   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to stop   
  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::StopDMAChannel( UCHAR ucDMAChannel )   
  {   
    UCHAR ucIOVal;   
    ULONG ulFrameCount = 0;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // Stop DAC0   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bDEVCTL_OFF,   
                  ES1371_DEVCTL_DAC0_EN, ucIOVal );   
     
        // disable the DAC0 interrupt   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_DAC0IE, ucIOVal );   
     
        if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState )   
        {   
          // modify pause bit for DAC0   
          ucIOVal = 0;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC0PAUSE, ucIOVal );   
        }   
     
        // Clear out the Current Frame count register   
        ulFrameCount = HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF);  
    
        HwPagedIOWrite( ES1371_DAC0CTL_PAGE,    
                        ES1371_wDAC0FC_OFF,   
                        ulFrameCount & 0x0000ffff );    
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED;   
        break;   
     
      case ES1371_DAC1 :   
        // Stop DAC1   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bDEVCTL_OFF,   
                  ES1371_DEVCTL_DAC1_EN, ucIOVal);   
     
        // disable the DAC1 interrupt   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_DAC1IE, ucIOVal);   
     
        if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState )   
        {   
          // modify pause bit for DAC0   
          ucIOVal = 0;   
          HwRegRMW( ES1371_bSERCTL_OFF,   
                    ES1371_SERCTL_DAC1PAUSE, ucIOVal );   
        }   
     
        // Clear out the Current Frame count register   
        ulFrameCount = HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF);  
    
        HwPagedIOWrite( ES1371_DAC1CTL_PAGE,    
                        ES1371_wDAC1FC_OFF,   
                        ulFrameCount & 0x0000ffff );    
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED;   
        break;   
     
      case ES1371_ADC :   
        // Stop ADC   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bDEVCTL_OFF,   
                  ES1371_DEVCTL_ADC_EN, ucIOVal);   
     
        // disable the ADC interrupt   
        ucIOVal = 0;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_ADCIE, ucIOVal);   
     
        // Clear out the Current Frame count register   
        ulFrameCount = HwPagedIORead( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF);    

        HwPagedIOWrite( ES1371_ADCCTL_PAGE,    
                        ES1371_wADCFC_OFF,   
                        ulFrameCount & 0x0000ffff );    
     
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED;   
        break;   
    }   
    return;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: PauseDMAChannel   
  //   
  //  Description: Pause a particular DMA channel.   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to pause   
  //   
  //  Returns: none      
  //   
  //  Note:   
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::PauseDMAChannel( UCHAR ucDMAChannel )   
  {   
    UCHAR ucIOVal;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // wait until interrupt count is non-zero   
  //      while ( !HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0CIC_OFF));    

     
        // modify pause bit for DAC0   
        ucIOVal = ES1371_SERCTL_DAC0PAUSE;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_DAC0PAUSE, ucIOVal );   
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_PAUSED;   
        break;   
     
      case ES1371_DAC1 :   
        // wait until interrupt count is non-zero   
  //      while ( !HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1CIC_OFF));    

     
        // modify pause bit for DAC1   
        ucIOVal = ES1371_SERCTL_DAC1PAUSE;   
        HwRegRMW( ES1371_bSERCTL_OFF,   
                  ES1371_SERCTL_DAC1PAUSE, ucIOVal);   
        // save the state   
        m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_PAUSED;   
        break;   
     
      case ES1371_ADC :   
        break;   
    }   
    return;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: GetDMAPosition   
  //   
  //  Description: reads the current position of a DMA channel.   
  //   
  //  Parameters: UCHAR ucDMAChannel : Index of the DMA channel   
  //   
  //  Returns: ULONG current DMA position in bytes     
  //   
  //  Note: This function returns the DMA position NOT the sample play   
  //        cursor.  It appears that this will be used for buffer filling.   
  //   
  //--------------------------------------------------------------------------   

  ULONG   
  CES1371::GetDMAPosition( UCHAR ucDMAChannel )   
  {   
    ULONG ulCurrentPos = 0;   
     
    switch ( ucDMAChannel )   
    {   
      case ES1371_DAC0 :   
        // read the Frame register   
        ulCurrentPos = HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF);  
    
        // the current frame count is in the upper WORD   
        ulCurrentPos >>= 16;   
     
        // multiply the DWORD count by 4 to get a BYTE count to return   
        ulCurrentPos *= 4;   
        break;   
     
      case ES1371_DAC1 :   
        // read the Frame register   
        ulCurrentPos = HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF);  
    
        // the current frame count is in the upper WORD   
        ulCurrentPos >>= 16;   
     
        // multiply the DWORD count by 4 to get a BYTE count to return   
        ulCurrentPos *= 4;   
        break;   
     
      case ES1371_ADC :   
        // read the Frame register   
        ulCurrentPos = HwPagedIORead( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF);    

        // the current frame count is in the upper WORD   
        ulCurrentPos >>= 16;   
     
        // multiply the DWORD count by 4 to get a BYTE count to return   
        ulCurrentPos *= 4;   
        break;   
    }   
    return ulCurrentPos;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: GetInterruptSource   
  //   
  //  Description: returns the source of the current interrupt   
  //   
  //  Parameters: none   
  //   
  //  Returns: UCHAR LONG current DMA position in bytes     
  //   
  //--------------------------------------------------------------------------   

  UCHAR   
  CES1371::GetInterruptSource( void )   
  {   
      ULONG intstat;   
      UCHAR intsrc;   
     
      intstat = READ_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSTATUS_OFF) );    

     
      // If we get all f's back we can't see the hardware   
      if ( 0xffffffff == intstat )   
        return ES1371_INT_NONE;   
     
      if ( !( ES1371_INTSTAT_PENDING & intstat ))   
        return ES1371_INT_NONE;   
     
      intsrc = (UCHAR)(intstat) & ES1371_INT_MASK;   
     
      return intsrc;   
  }   
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: AckDMAInterrupt   
  //   
  //  Description: clean up a (set of) interrupt(s)    
  //   
  //  Parameters: UCHAR ucIntSrc : a bit mask interrupts to ack   
  //   
  //  Returns: none     
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::AckDMAInterrupt( UCHAR ucIntSrc )   
  {   
      UCHAR ackmask = 0;   
     
      if ( ES1371_INT_ADC & ucIntSrc )   
         ackmask |= ES1371_SERCTL_ADCIE ;   
     
      if ( ES1371_INT_DAC0 & ucIntSrc )   
         ackmask |= ES1371_SERCTL_DAC0IE ;   
     
      if ( ES1371_INT_DAC1 & ucIntSrc )   
         ackmask |= ES1371_SERCTL_DAC1IE ;   
     
      // now ack the interrupts - first set the IEs to 0   
      HwRegRMW( ES1371_bSERCTL_OFF, ackmask, 0x00);   
     
      // then set the IEs back to 1   
      HwRegRMW( ES1371_bSERCTL_OFF, ackmask, ackmask);   
  }   
        
     
  //--------------------------------------------------------------------------   

  //   
  //  Name: JoystickEnable   
  //   
  //  Description: Enable or disable the joystick port IO range    
  //   
  //  Parameters:    
  //     ULONG ulIOPort : The starting IO address to use or 0 to disable   
  //   
  //  Returns: none     
  //   
  //--------------------------------------------------------------------------   

  void   
  CES1371::JoystickEnable( ULONG ulIOPort )   
  {   
      UCHAR joyio = 0;   
     
      if ( ( 0x00000200 == ulIOPort ) ||   
           ( 0x00000208 == ulIOPort ) ||   
           ( 0x00000210 == ulIOPort ) ||   
           ( 0x00000218 == ulIOPort ) )   
      {   
           // move the two useful bits to the correct position   
           joyio = UCHAR( ulIOPort >> 3 ) ;   
     
           // set the two bits that control the joystick io range   
           HwRegRMW( ES1371_bJOYCTL_OFF, 0x03, joyio );   
     
           // enable the joystick port   
           joyio = ES1371_DEVCTL_JSTICK_EN ;   
           HwRegRMW( ES1371_bDEVCTL_OFF, ES1371_DEVCTL_JSTICK_EN, joyio );   
      }   
      else // disable   
      {   
           // disable the joystick port   
           joyio = 0;   
           HwRegRMW( ES1371_bDEVCTL_OFF, ES1371_DEVCTL_JSTICK_EN, joyio );   
      }        
  }   
        
     
  /***************************************************************************** 
   
   * SynchronizedPagedIO()  
   ***************************************************************************** 
   
   * Do paged IO syncronized with the ISR.  
   */   
  NTSTATUS   
  SynchronizedPagedIO   
  (   
      IN      PINTERRUPTSYNC  InterruptSync,   
      IN      PVOID           syncIOContext   
  )   
  {   
      PSYNCIOCONTEXT context;   
     
      context = (PSYNCIOCONTEXT)syncIOContext;   
      ASSERT(context->pHardware);   
      ASSERT(context->ulPage);   
      ASSERT(context->ulIOAddress);   
     
      NTSTATUS ntStatus = STATUS_SUCCESS;   
     
      // write the page register if needed   
      if ( context->pHardware->m_ulDRegs[ES1371_bMEMPAGE_OFF/4] != 
  context->ulPage )   
      {   
          WRITE_PORT_UCHAR(context->pHardware->m_pPciAddr + ES1371_bMEMPAGE_OFF, 
     
                           UCHAR(context->ulPage) & 0x0f );   
          // save in the regs array   
          context->pHardware->m_ulDRegs[ES1371_bMEMPAGE_OFF/4] = 
  context->ulPage;   
      }   
     
      // read or write the data   
      if ( context->fRead )   
      {   
          *(context->pulData) =    
              READ_PORT_ULONG(    
                 PULONG(context->pHardware->m_pPciAddr + context->ulIOAddress) 
  );   
      }   
      else // write   
      {   
          WRITE_PORT_ULONG(    
                 PULONG(context->pHardware->m_pPciAddr + context->ulIOAddress),  
   
                 *(context->pulData) );   
      }   
     
      return ntStatus;   
  }   
     
// 
// Copyright (c) Microsoft Corporation.  All rights reserved. 
// 
// 
// Use of this source code is subject to the terms of the Microsoft end-user 
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT. 
// If you did not accept the terms of the EULA, you are not authorized to use 
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your 
// install media. 
// 
// 
// Copyright 1998-2000 (c) Creative Labs, Malvern.  All rights reserved. 
// 
// $Workfile: es1371.cpp $    
// 
 
#include <windows.h> 
#include <waveddsi.h> 
#include <ceddk.h> 
#include "es1371.h" 
 
DWORD gIntrAudio; 
 
#define STR_MODULENAME "CES1371: " 
 
typedef struct 
{ 
    CES1371           * pHardware; 
    BOOLEAN             fRead; 
    ULONG               ulPage; 
    ULONG               ulIOAddress; 
    PULONG              pulData; 
} 
SYNCIOCONTEXT, *PSYNCIOCONTEXT; 
 
static 
NTSTATUS 
SynchronizedPagedIO 
( 
    IN      PINTERRUPTSYNC  InterruptSync, 
    IN      PVOID           syncIOContext 
); 
 
// {{{ constructor/destructor 
 
CES1371::CES1371 (void) 
{ 
	m_pInterruptSync = (IInterruptSync_WinCeStub*)new IInterruptSync_WinCeStub; 
	m_fIsMapped = FALSE; 
	m_refcount = 0; 
	m_ulPowerState = 0; 
} 
 
 
CES1371::~CES1371 () 
{ 
    //invalidate our member variables 
	if (m_fIsMapped) { 
		MmUnmapIoSpace(m_pPciAddr, ES1371_IO_SPACE_SIZE); 
		m_fIsMapped = FALSE; 
	} 
    m_pPciAddr = 0; 
} 
 
LONG CES1371::AddRef (void) 
{ 
	return InterlockedIncrement (&m_refcount); 
} 
 
LONG CES1371::Release (void) 
{ LONG newcount; 
 
	newcount = InterlockedDecrement (&m_refcount); 
	if (newcount == 0) {  
		delete this; 
	} 
	return newcount; 
} 
 
 
 
// }}} 
 
// {{{ Init 
 
//-------------------------------------------------------------------------- 
// 
//  Name: CES1371::MapHardware 
// 
//  Description: Maps port address, assigns SysIntr 
// 
//  Parameters: none 
// 
//  Returns: BOOL 
//		TRUE if device was mapped properly 
//		FALSE if device could not be mapped	 
// 
//  Note:  
// 
//-------------------------------------------------------------------------- 
BOOL CES1371::MapHardware (ULONG ulSysIntr, ULONG ulPciAddr, ULONG ulPciLength, ULONG ulDeviceID, ULONG ulRevisionID) 
{ 
	PHYSICAL_ADDRESS	PortAddress; 
	PHYSICAL_ADDRESS	MappedAddress; 
 
	//initialize our member variables 
	m_pPciAddr = (PUCHAR)ulPciAddr; 
	 
	// 
	// Configure IO address 
	// 
	{ 
		// 
		// Translate address 
		// 
		DWORD inIoSpace = 1;	// io space     
		PortAddress.LowPart  = (DWORD)m_pPciAddr; 
		PortAddress.HighPart = 0;  
		 
		if (!HalTranslateBusAddress(PCIBus, 0, PortAddress, &inIoSpace, &MappedAddress)) { 
			DEBUGMSG(1, (L"CES1371::MapHardware - failed HalTranslateBusAddress\r\n")); 
			return FALSE; 
		} 
		 
 
		if (!inIoSpace) { 
			// Get virtual address 
            if ((m_pPciAddr = (PUCHAR)MmMapIoSpace(MappedAddress, ulPciLength, FALSE)) == NULL) { 
                DEBUGMSG(1, (TEXT("CES1371::MapHardware -  Error mapping I/O Ports.\r\n"))); 
                return FALSE; 
            } 
            DEBUGMSG(1, (L"CES1371::MapHardware - MappedAddress = 0x%X, m_pPciAddr = 0x%X\r\n", MappedAddress.LowPart, m_pPciAddr)); 
        } else { 
            m_pPciAddr = (PUCHAR)MappedAddress.LowPart; 
        } 
	} 
 
	DEBUGMSG(1, (L"CES1371::MapHardware2 - MappedAddress = 0x%X, m_pPciAddr = 0x%X\r\n", MappedAddress.LowPart, m_pPciAddr)); 
 
	// 
	// Configure Interrupt  
	// 
	gIntrAudio = ulSysIntr; 
 
    // record the Device ID and Revision ID for posterity. 
    m_usDid = (USHORT)ulDeviceID; 
    m_ucRevision = (UCHAR)ulRevisionID; 
 
    //call our initialization functions 
    InitHardware(); 
 
    return TRUE; 
}	 
 
//-------------------------------------------------------------------------- 
// 
//  Name: CES1371::InitHardware 
// 
//  Description: intitializes the 1371 hardware 
// 
//  Parameters: none 
// 
//  Returns: void 
// 
//  Note:  
// 
//-------------------------------------------------------------------------- 
void CES1371::InitHardware() 
{ 
    UCHAR  bReg = 0x00; 
    USHORT wReg = 0x0000; 
    ULONG  i; 
 
    // if we have a 5880 then take the AC97 codec out of reset 
    if ( (m_usDid == ES5880_PCI_DEVID)                          || 
         ((m_usDid == ES1371_PCI_DEVID) && (m_ucRevision == 7)) ||  
         ((m_usDid == ES1371_PCI_DEVID) && (m_ucRevision >= 9)) 
       ) 
    { 
        // write the es137x AC97 reset bit 
        bReg = 0x20; 
        HwRegRMW( ES1371_bINTSUMM_OFF, 0x20, bReg ); 
 
        // wait around a long time for the codec to come out of reset 
        // i.e. 20 msec or 200 * 100 nanosec 
#ifdef UNDER_CE 
        Sleep(1); 
#else 
        if ( KeGetCurrentIrql() == PASSIVE_LEVEL ) 
        { 
            LARGE_INTEGER liTimeout = 
                   RtlConvertLongToLargeInteger( -200 );  
 
            KeDelayExecutionThread( KernelMode, FALSE, &liTimeout ); 
        } 
        else // wait around the old fashioned way by polling 
        { 
            ULONG ulPollCount; 
            UCHAR ucDummyRead; 
 
            for ( ulPollCount = 0; ulPollCount < 110000; ulPollCount++ ) 
            { 
                ucDummyRead = READ_PORT_UCHAR( m_pPciAddr ); 
            } 
        } 
#endif 
 
		// The 5880 has a mux to configure the line in/rear spkr out 
		// jack to the appropriate function.  In the basic driver, 
		// we'll assume it'll always be a line in function (set 
		// GPIO2 bit to zero). 
		HwRegRMW( ES1371_bGPIO_OFF, (UCHAR)0x04, (UCHAR) 0x00); 
 
    } 
 
    // write bogus values into the DRegs so the initial writes take 
    for ( i=0; i<12; i++) 
      m_ulDRegs[i] = 0xffffffff; 
     
    /* 
     *put the HW into a happy state 
     */   
    InitSRC( TRUE ); 
     
    /* setup the MISCCTRL reg */ 
    bReg = 
        ES1371_MISCCTL_PDLEV_D0 
        & ~ES1371_MISCCTL_CCBINTRM_EN; 
 
    HwRegRMW( ES1371_bMISCCTL_OFF, 0xff, bReg ); 
     
    /* setup the DEVCTRL reg */ 
    /* enable UART, XTAL clock and PCI clock */ 
    bReg = 
         ES1371_DEVCTL_UART_EN  
        & ~ES1371_DEVCTL_XTALCLK_DS 
        & ~ES1371_DEVCTL_PCICLK_DS; 
     
    HwRegRMW( ES1371_bDEVCTL_OFF, 0xff, bReg ); 
 
    /* setup the JOYCTRL reg */ 
    bReg = 0; 
    HwRegRMW( ES1371_bJOYCTL_OFF, 0xff, bReg ); 
     
    /* disable the NMI */ 
    bReg = 0x00; 
    HwRegRMW( ES1371_bNMIENA_OFF, 0xff, bReg ); 
     
    /* clear the NMI status register */ 
    wReg = 0x0000; 
    HwRegRMW( ES1371_wNMISTAT_OFF, 0xffff, wReg ); 
     
    /* clear the Serial Control register */ 
    bReg = 0x00; 
    HwRegRMW( ES1371_bSERCTL_OFF, 0xff, bReg ); 
     
    // initialize Codec 
    InitCodec(); 
 
    // initialize UART 
    m_ulUARTState = 0; 
 
	// 
	// Cycle the power state to get registers image, etc. 
	// 
	//SetPowerState(1);	// Turn off to set register arrays  
	//SetPowerState(0); 
 
    return; 
} 
 
// }}} 
 
// {{{ SRCInit 
 
void CES1371::InitSRC( BOOLEAN fEnable ) 
{ 
    USHORT     i; 
    ULONG      ulHardwareWrite; 
 
    /* must poll before writes to DISABLE or PAUSE the SRCIO register */ 
    SRCPollIOReg (); 
    /* disable SRC for init */ 
    ulHardwareWrite = SRC_DISABLE; 
    HwRegRMW( ES1371_dSRCIO_OFF, 0xffffffff, ulHardwareWrite );  
//    WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), SRC_DISABLE); 
 
    /* clear the SRC RAM */ 
    for( i = 0; i < 0x80; ++i ) 
        SRCRegWrite(i, 0 ); 
 
    SRCRegWrite(SRC_DAC0_BASE + SRC_TRUNC_N_OFF, 16 << 4); 
    SRCRegWrite(SRC_DAC0_BASE + SRC_INT_REGS_OFF, 16 << 10); 
    SRCRegWrite(SRC_DAC1_BASE + SRC_TRUNC_N_OFF, 16 << 4); 
    SRCRegWrite(SRC_DAC1_BASE + SRC_INT_REGS_OFF, 16 << 10); 
    SRCRegWrite(SRC_ADC_BASE + SRC_TRUNC_N_OFF, 16 << 4); 
    SRCRegWrite(SRC_ADC_BASE + SRC_INT_REGS_OFF, 16 << 10); 
    SRCRegWrite(SRC_DAC0_VOL_L, 1 << 12); 
    SRCRegWrite(SRC_DAC0_VOL_R, 1 << 12); 
    SRCRegWrite(SRC_DAC1_VOL_L, 1 << 12); 
    SRCRegWrite(SRC_DAC1_VOL_R, 1 << 12); 
    SRCRegWrite(SRC_ADC_VOL_L, 1 << 12); 
    SRCRegWrite(SRC_ADC_VOL_R, 1 << 12); 
 
    /* default some rates */ 
    SRCSetRate(ES1371_DAC0, 22050); 
    SRCSetRate(ES1371_DAC1, 22050); 
    SRCSetRate(ES1371_ADC, 22050); 
 
#if (DBG) 
    USHORT usSRCdata[8]; 
    USHORT j; 
    /* dump the SRC ram */ 
    DEBUGMSG( 1, (TEXT("es1371 dump SRC ram\r"))); 
 
    for ( i = 0; i < 16; i++ ) 
    { 
      for ( j = 0; j < 8; j++) 
      { 
          usSRCdata[j] = SRCRegRead( i*8 + j );   
      } 
 
      DEBUGMSG( 1, (TEXT("%02x %04x %04x %04x %04x %04x %04x %04x %04x\r"), i*8, 
                                      usSRCdata[0],usSRCdata[1], 
                                      usSRCdata[2],usSRCdata[3], 
                                      usSRCdata[4],usSRCdata[5], 
                                      usSRCdata[6],usSRCdata[7])); 
    } 
#endif 
 
    if ( fEnable ) 
    { 
        /* now enable the whole deal */ 
        SRCPollIOReg (); 
        ulHardwareWrite = 0L; 
        HwRegRMW( ES1371_dSRCIO_OFF, 0xffffffff, ulHardwareWrite );  
    } 
 
    return; 
} 
 
// }}} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: HwPagedIOWrite 
// 
//  Description: Does a MP-safe write to the indirect registers 
// 
//  Parameters: UCHAR Page : the memory page to set 
//              PULONG pAddr : the IO address to write 
//              ULONG ulData : the data to write 
// 
//  Returns: NTSTATUS     
// 
//-------------------------------------------------------------------------- 
NTSTATUS 
CES1371::HwPagedIOWrite( UCHAR Page, ULONG pAddr, ULONG ulData ) 
{ 
    SYNCIOCONTEXT context; 
    ULONG ulWriteData; 
 
    NTSTATUS ntStatus = STATUS_SUCCESS; 
 
    if ( 0 == m_ulPowerState ) 
    { 
        // normal power state - go read the hardware 
        ulWriteData = ulData; 
 
        context.pHardware = this; 
        context.fRead = FALSE; 
        context.ulPage = ULONG( Page ); 
        context.ulIOAddress = pAddr; 
        context.pulData = &ulWriteData; 
 
        ntStatus = m_pInterruptSync-> 
                     CallSynchronizedRoutine(SynchronizedPagedIO,PVOID(&context)); 
    } 
    else 
    { 
        // power down state - can't write hardware write the saved setting 
        m_ulIRegsPMContext[ (ULONG(Page) * 4) + ( (pAddr - 0x30) / 4 ) ] = ulData; 
    } 
 
    return ntStatus; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: HwPagedIORead 
// 
//  Description: Sets the current page of indirect registers 
// 
//  Parameters: UCHAR Page : the memory page to set 
//              PULONG pAddr : the IO address to read 
// 
//  Returns: data read    
// 
//-------------------------------------------------------------------------- 
ULONG 
CES1371::HwPagedIORead( UCHAR Page, ULONG pAddr ) 
{ 
    SYNCIOCONTEXT context; 
    ULONG ulReadData; 
 
    NTSTATUS ntStatus = STATUS_SUCCESS; 
 
    if ( 0 == m_ulPowerState ) 
    { 
        // normal power state - go read the hardware 
        context.pHardware = this; 
        context.fRead = TRUE; 
        context.ulPage = ULONG( Page ); 
        context.ulIOAddress = pAddr; 
        context.pulData = &ulReadData; 
 
        ntStatus = m_pInterruptSync-> 
                     CallSynchronizedRoutine(SynchronizedPagedIO,PVOID(&context)); 
    } 
    else 
    { 
        // power down state - can't read hardware get the saved setting 
        ulReadData = m_ulIRegsPMContext[ (ULONG(Page) * 4) + ( (pAddr - 0x30) / 4 ) ]; 
    } 
 
    return ulReadData; 
} 
 
// {{{ HwRegRMW 
/* -----------------------------------------------------------------------  / 
 
    Routine:  HwRegRMW 
 
    Purpose:  The routine is used to access a Concert chip register via 
              its shadowed value.  This routine is required to provide 
              exclusion (synchronization) to the register. 
 
              This routine should be run from the KeSynchronizeExecution 
              call,  forceing this routine to execute at our devices 
              DIRQL.  It also acquires the spin lock, providing exclusion. 
 
              The current value in the shadow ram is read, ANDed with 
              the mask and ORed with the bits. 
 
 
    Inputs: 
 
    Output:   None 
 
    Errors:   None 
 
/  ----------------------------------------------------------------------- */ 
UCHAR 
CES1371::HwRegRMW (  UCHAR Reg, UCHAR bBitMask, UCHAR bSetBits ) 
{ 
   UCHAR bNewValue; 
   UCHAR *puc_DRegs = (UCHAR *)m_ulDRegs; 
 
   // are we setting the whole data space? 
   if ( 0x00 == bBitMask ) 
   { 
       return ( *(puc_DRegs + Reg) ); 
   } 
   else if ( 0xff == bBitMask ) 
   { 
       bNewValue = bSetBits; 
   } 
   else 
   { 
       // read original value,  
       // zero out bits of interest,  
       // set proper bits to one  
       if ( (0xff != *(puc_DRegs + Reg)) || ( m_ulPowerState > 0 ) ) 
           bNewValue = *(puc_DRegs + Reg); 
       else 
           bNewValue = READ_PORT_UCHAR (m_pPciAddr + Reg); 
       bNewValue &= ~bBitMask; 
       bNewValue |= (bSetBits & bBitMask); 
   } 
   // write new value to hardware 
   if ( 0 == m_ulPowerState ) 
       WRITE_PORT_UCHAR ( m_pPciAddr + Reg, bNewValue); 
 
   // save the value for the future 
   *(puc_DRegs + Reg) = bNewValue; 
 
   return bNewValue; 
 
}  // end of function: hw_reg_rmw_char 
 
// }}} 
 
// {{{ HwRegRMW 
USHORT 
CES1371::HwRegRMW ( UCHAR Reg, USHORT wBitMask, USHORT wSetBits ) 
{ 
   USHORT wNewValue; 
   USHORT *pus_DRegs = (USHORT *)m_ulDRegs; 
    
   // are we setting the whole data space? 
   if ( 0x0000 == wBitMask ) 
   { 
       return ( *(pus_DRegs + Reg/2) ); 
   } 
   else if ( 0xffff == wBitMask ) 
   { 
       wNewValue = wSetBits; 
   } 
   else 
   { 
       // read original value,  
       // zero out bits of interest,  
       // set proper bits to one 
       if ( (0xffff != *(pus_DRegs + (Reg/2))) || ( m_ulPowerState > 0 ) ) 
           wNewValue = *(pus_DRegs + (Reg/2)); 
       else 
           wNewValue = READ_PORT_USHORT ( (PUSHORT)(m_pPciAddr + Reg) ); 
       wNewValue &= ~wBitMask; 
       wNewValue |= (wSetBits & wBitMask); 
   } 
      
   /* write new value to hardware */ 
   if ( 0 == m_ulPowerState ) 
       WRITE_PORT_USHORT ( (PUSHORT)(m_pPciAddr + Reg), wNewValue ); 
    
   // save the value for the future 
   *(pus_DRegs + (Reg/2)) = wNewValue; 
 
   return wNewValue; 
   
}  /* end of function: hw_reg_rmw_short */ 
 
// }}} 
 
// {{{ HwRegRMW 
ULONG 
CES1371::HwRegRMW ( UCHAR Reg, ULONG dwBitMask, ULONG dwSetBits ) 
{ 
   ULONG dwNewValue; 
 
   // are we setting the whole data space? 
   if ( 0x00000000 == dwBitMask ) 
   { 
       return ( m_ulDRegs[Reg/4] ); 
   } 
   else if ( 0xffffffff == dwBitMask ) 
   { 
       dwNewValue = dwSetBits; 
   } 
   else 
   { 
       // read original value,  
       // zero out bits of interest,  
       // set proper bits to one  
       if ( (0xffffffff != m_ulDRegs[Reg/4]) || ( m_ulPowerState > 0 ) ) 
           dwNewValue = m_ulDRegs[Reg/4]; 
       else 
           dwNewValue = READ_PORT_ULONG ( (PULONG)(m_pPciAddr + Reg) ); 
 
       dwNewValue &= ~dwBitMask; 
       dwNewValue |= (dwSetBits & dwBitMask); 
   } 
 
   /* write new value to hardware */ 
   if ( 0 == m_ulPowerState ) 
       WRITE_PORT_ULONG ( (PULONG)(m_pPciAddr + Reg), dwNewValue ); 
 
   // save the value for the future 
   m_ulDRegs[Reg/4] = dwNewValue; 
 
   return dwNewValue; 
 
}  /* end of function: hw_reg_rmw_long */ 
 
// }}} 
 
// {{{ SRCRegRead 
 
USHORT 
CES1371::SRCRegRead( USHORT reg ) 
{ 
   /* LOCAL DATA */ 
   ULONG    dtemp; 
   /* END LOCAL DATA */ 
 
   // Is the device powered down? 
   if ( m_ulPowerState > 0 ) 
        return m_usSRCRegsPMContext[ reg ]; 
 
   /* wait for ready */ 
   dtemp = SRCPollIOReg (); 
     
   /* assert a read request */ 
   WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), 
                    (dtemp & SRC_CTLMASK) | (ULONG(reg) << 25) ); 
 
   /* wait for the data */ 
   dtemp = SRCPollIOReg (); 
   return (USHORT) dtemp; 
} 
 
// }}} 
 
void  
CES1371::SRCRegWrite(USHORT reg, USHORT val) 
{ 
    ULONG    i, dtemp; 
 
    // Is the device powered down? 
    if ( m_ulPowerState > 0 ) 
    { 
        m_usSRCRegsPMContext[ reg ] = val; 
        return; 
    } 
 
    /* wait for ready */ 
    dtemp = SRCPollIOReg (); 
 
    /* assert the write request */ 
    i = (dtemp & SRC_CTLMASK) | SRC_WENABLE | 
            ( (ULONG)reg << 25 ) | val; 
 
    /* write the value */ 
    WRITE_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), i); 
 
#ifdef DBG 
    { 
      USHORT us; 
      us = SRCRegRead ( reg ); 
      if ( us != val ) 
        _DbgPrintF( DEBUGLVL_TERSE, ("[SRCRegWrite] FAILED reg %02x wrote %04x read %04x", reg, val, us)); 
    } 
#endif 
 
    return; 
} 
 
// }}} 
 
 
void 
CES1371::SRCSetRate( UCHAR ucDMAChannel, USHORT wSampleRate ) 
{ 
    ULONG    i, freq, dtemp; 
    USHORT   N, truncM, truncStart, wtemp; 
 
    // Is the device powered down? 
    if ( m_ulPowerState > 0 ) 
        return; 
 
    switch ( ucDMAChannel ) 
    { 
      case ES1371_DAC0: 
        // freeze the channel 
        for( i = 0; i < SRC_IOPOLL_COUNT; ++i ) 
            if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & SRC_BUSY) ) 
                break; 
 
        dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF)); 
        WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), 
                (dtemp & SRC_CTLMASK) | SRC_DAC0FREEZE); 
 
        // calculate new frequency and write it 
        // preserve accum  
        freq = ((ULONG) wSampleRate << 16) / 3000U; 
        SRCRegWrite( SRC_DAC0_BASE + SRC_INT_REGS_OFF,  
                     (SRCRegRead( SRC_DAC0_BASE + SRC_INT_REGS_OFF ) & 0x00ffU) | 
                       ((USHORT) (freq >> 6) & 0xfc00)); 
        SRCRegWrite( SRC_DAC0_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1); 
 
        // un-freeze the channel 
        for( i = 0; i < SRC_IOPOLL_COUNT; ++i ) 
            if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & SRC_BUSY) ) 
                break; 
        dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF)); 
        WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), 
                (dtemp & SRC_CTLMASK) & (~SRC_DAC0FREEZE) ); 
        break; 
 
      case ES1371_DAC1: 
        // freeze the channel 
        for( i = 0; i < SRC_IOPOLL_COUNT; ++i ) 
            if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & SRC_BUSY) ) 
                break; 
 
        dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF)); 
        WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), 
                (dtemp & SRC_CTLMASK) | SRC_DAC1FREEZE); 
 
        // calculate new frequency and write it 
        // preserve accum  
        freq = ((ULONG) wSampleRate << 16) / 3000U; 
        SRCRegWrite( SRC_DAC1_BASE + SRC_INT_REGS_OFF,  
                     (SRCRegRead( SRC_DAC1_BASE + SRC_INT_REGS_OFF ) & 0x00ffU) | 
                       ((USHORT) (freq >> 6) & 0xfc00)); 
        SRCRegWrite( SRC_DAC1_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1); 
 
        // un-freeze the channel 
        for( i = 0; i < SRC_IOPOLL_COUNT; ++i ) 
            if( !(READ_PORT_ULONG ( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & SRC_BUSY) ) 
                break; 
        dtemp = READ_PORT_ULONG((PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF)); 
        WRITE_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF), 
                (dtemp & SRC_CTLMASK) & (~SRC_DAC1FREEZE) ); 
        break; 
 
      case ES1371_ADC: 
        // derive oversample ratio 
        N = wSampleRate/3000U; 
        if( N == 15 || N == 13 || N == 11 || N == 9 ) 
            --N; 
 
        // truncate the filter and write n/trunc_start 
        truncM = (21*N - 1) | 1; 
        if( wSampleRate >= 24000U ) 
        { 
            if( truncM > 239 ) 
                truncM = 239; 
            truncStart = (239 - truncM) >> 1; 
             
            SRCRegWrite( SRC_ADC_BASE + SRC_TRUNC_N_OFF, 
                         (truncStart << 9) | (N << 4)); 
        } 
        else 
        { 
            if( truncM > 119 ) 
                truncM = 119; 
            truncStart = (119 - truncM) >> 1; 
 
            SRCRegWrite( SRC_ADC_BASE + SRC_TRUNC_N_OFF, 
                    0x8000U | (truncStart << 9) | (N << 4)); 
        } 
 
        /* calculate new frequency and write it - preserve accum */ 
        freq = ((48000UL << 16) / wSampleRate) * N; 
        wtemp = SRCRegRead( SRC_ADC_BASE + SRC_INT_REGS_OFF ); 
        SRCRegWrite( SRC_ADC_BASE + SRC_INT_REGS_OFF, 
                     (wtemp & 0x00ff) | ((USHORT) (freq >> 6) & 0xfc00)); 
        SRCRegWrite( SRC_ADC_BASE + SRC_VFREQ_FRAC_OFF, (USHORT) freq >> 1); 
 
        SRCRegWrite( SRC_ADC_VOL_L, N << 8); 
        SRCRegWrite( SRC_ADC_VOL_R, N << 8); 
        break; 
    } 
 
    return; 
} 
 
 
//-------------------------------------------------------------------------- 
// 
//  Name: SRCWaitForFrame1 
// 
//  Description: code that polls a value in the SRC converter so that we know 
//               when it is safe to write. 
// 
//  Parameters:  PFRAME_CONTEXT 
// 
//  Returns: always succeeds 
// 
//  Note: Apparently, we can't do CODEC writes when the sync pulse is high. 
//        Luckily, there are some debug things in the SRC that let us know 
//        when sync pulse is low. This needs to be synched with the ISR so 
//        we don't get interrupted and lose track of where we are. 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::SRCWaitForFrame1 ( ) 
{ 
    while( !((READ_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSRCIO_OFF) ) & 0x00070000UL) == 
          0x00010000UL) ) 
//<mod:ce> KeStallExecutionProcessor(1); 
 
    return; 
} 
 
// }}} 
    
// {{{ SRCPollIOReg 
 
//-------------------------------------------------------------------------- 
// 
//  Name: SRCPollIOReg 
// 
//  Description: 
// 
//  Parameters:  
// 
//  Returns:     
// 
//  Note: This function must be called prior to any 
//        writes to the Disable/Pause bits 
// 
//-------------------------------------------------------------------------- 
ULONG 
CES1371::SRCPollIOReg () 
{ 
  int i; 
  ULONG dw=0; 
 
  for (i=0; i<SRC_IOPOLL_COUNT; ++i) 
  { 
        if (!((dw = READ_PORT_ULONG ((PULONG)(m_pPciAddr+ES1371_dSRCIO_OFF))) & SRC_BUSY) ) 
          break; 
 
//<mod:ce> KeStallExecutionProcessor (1); 
  } 
 
#ifdef DBG 
  if (i == SRC_IOPOLL_COUNT) 
        _DbgPrintF( DEBUGLVL_TERSE, ("[SRCPollIOReg] timeout %x", dw)); 
#endif 
 
  return dw; 
} 
 
// }}} 
     
//-------------------------------------------------------------------------- 
// 
//  Name: InitDMAChannel 
// 
//  Description: Intialize all the things about a DMA channel 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to init 
//              ULONG ulPhysDMAAddr : Physical address of the DMA buffer 
//                                    in memory 
//              USHORT usBufferSize : Number of bytes in a DMA buffer 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::InitDMAChannel( UCHAR ucDMAChannel, 
                         ULONG ulPhysDMAAddr, 
                         ULONG ulBufferSize ) 
{ 
  ULONG ulFrameCount = 0; 
 
  m_dmachannel[ucDMAChannel].ulPhysDMAAddr = ulPhysDMAAddr; 
  m_dmachannel[ucDMAChannel].ulDMABufSize  = ulBufferSize; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // Set up the physical DMA buffer address 
      HwPagedIOWrite( ES1371_DAC0CTL_PAGE, ES1371_dDAC0PADDR_OFF, ulPhysDMAAddr);   
      // Clear out the Frame count register 
      HwPagedIOWrite( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF, ulFrameCount);   
      break; 
 
    case ES1371_DAC1 : 
      // Set up the physical DMA buffer address 
      HwPagedIOWrite( ES1371_DAC1CTL_PAGE, ES1371_dDAC1PADDR_OFF, ulPhysDMAAddr);   
      // Clear out the Frame count register 
      HwPagedIOWrite( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF, ulFrameCount);   
      break; 
 
    case ES1371_ADC : 
      // Set up the physical DMA buffer address 
      HwPagedIOWrite( ES1371_ADCCTL_PAGE, ES1371_dADCPADDR_OFF, ulPhysDMAAddr);   
      // Clear out the Frame count register 
      HwPagedIOWrite( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF, ulFrameCount);   
      break; 
  } 
  return ; 
}   
 
//-------------------------------------------------------------------------- 
// 
//  Name: SetDMAChannelFormat 
// 
//  Description: Set the Format of a particular DMA channel. 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to init 
//              ULONG ulChannels   : Number of audio channels 1=mono 2=stereo 
//              ULONG ul16Bit      : flag for sample size 0=8bit 1=16bit 
//              ULONG ulSampleRate : actual number of samples/second. 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::SetDMAChannelFormat( UCHAR ucDMAChannel, 
                              ULONG ulChannels, 
                              ULONG ul16Bit, 
                              ULONG ulSampleRate ) 
{ 
  UCHAR ucFormatBits; 
  UCHAR ucSkipCount; 
 
  // save off the info for power managment 
  m_dmachannel[ucDMAChannel].ulChannels   = ulChannels; 
  m_dmachannel[ucDMAChannel].ul16Bit      = ul16Bit; 
  m_dmachannel[ucDMAChannel].ulSampleRate = ulSampleRate; 
 
  // first set the new sample rate 
  SRCSetRate ( ucDMAChannel, (USHORT) ulSampleRate ); 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // set format bits for DAC0 ...  
      ucFormatBits = 0x00; 
      if( 2 == ulChannels ) 
          ucFormatBits |= ES1371_PCM_DAC0_STEREO ; 
      if( 1 == ul16Bit ) 
          ucFormatBits |= ES1371_PCM_DAC0_16BIT ; 
 
      HwRegRMW( ES1371_bSERFMT_OFF,  
                ES1371_PCM_DAC0_STEREO|ES1371_PCM_DAC0_16BIT, 
                ucFormatBits );  
      break; 
 
    case ES1371_DAC1 : 
      // set format bits for DAC1 ...  
      ucFormatBits = 0x00; 
      if( 2 == ulChannels ) 
          ucFormatBits |= ES1371_PCM_DAC1_STEREO ; 
      if( 1 == ul16Bit ) 
      { 
          ucFormatBits |= ES1371_PCM_DAC1_16BIT ; 
          // set the SKIP register for proper playback 
          ucSkipCount = 0x10; 
          HwRegRMW( ES1371_bSKIPC_OFF, 0x18, ucSkipCount );  
      } 
      else 
      {   // set the SKIP register for proper playback 
          ucSkipCount = 0x08; 
          HwRegRMW( ES1371_bSKIPC_OFF, 0x18, ucSkipCount );  
      } 
 
      HwRegRMW( ES1371_bSERFMT_OFF,  
                ES1371_PCM_DAC1_STEREO|ES1371_PCM_DAC1_16BIT, 
                ucFormatBits );  
      break; 
 
    case ES1371_ADC : 
      // set format bits for ADC ...  
      ucFormatBits = 0x00; 
      if( 2 == ulChannels ) 
          ucFormatBits |= ES1371_PCM_ADC_STEREO ; 
      if( 1 == ul16Bit ) 
          ucFormatBits |= ES1371_PCM_ADC_16BIT ; 
  
      HwRegRMW( ES1371_bSERFMT_OFF,  
                ES1371_PCM_ADC_STEREO|ES1371_PCM_ADC_16BIT, 
                ucFormatBits );  
      break; 
  } 
  return ;   
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: SetDMAChannelBuffer 
// 
//  Description: Set the buffer sizes of a particular DMA channel. 
// 
//  Parameters: UCHAR ucDMAChannel    : Index of the DMA channel to init 
//              ULONG ulBufferLength  : Size in bytes of the whole DMA buffer 
//              ULONG ulSamplesPerInt : Count of samples before interrupting 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::SetDMAChannelBuffer( UCHAR ucDMAChannel, 
                              ULONG ulBufferLength, 
                              ULONG ulSamplesPerInt ) 
{ 
  ULONG ulDesiredBufferSize =  m_dmachannel[ucDMAChannel].ulDMABufSize; 
  USHORT usInterruptCount = (USHORT) (ulSamplesPerInt - 1); 
 
  m_dmachannel[ucDMAChannel].ulBufferLength  = ulBufferLength; 
  m_dmachannel[ucDMAChannel].ulSamplesPerInt = ulSamplesPerInt; 
 
  // buffer can't be bigger than half the physical buffer 
  ulDesiredBufferSize = MIN( ulDesiredBufferSize, ulBufferLength ) ; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // set the DAC0 DWORD frame count 
      HwPagedIOWrite( ES1371_DAC0CTL_PAGE,  
                      ES1371_wDAC0FC_OFF,  
                      (ulDesiredBufferSize/4 - 1) & 0x0000ffff );   
 
      // Write DAC0 interrupt count - sample frames per half-buffer (n-1). 
      HwRegRMW( ES1371_wDAC0IC_OFF, 0xffff, usInterruptCount ); 
//      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wDAC0IC_OFF), 
//                         (USHORT) (ulSamplesPerInt - 1) ) ; 
      break; 
 
    case ES1371_DAC1 : 
      // set the DAC1 DWORD frame count 
      HwPagedIOWrite( ES1371_DAC1CTL_PAGE,  
                      ES1371_wDAC1FC_OFF,  
                      (ulDesiredBufferSize/4 - 1) & 0x0000ffff );   
 
      // Write DAC1 interrupt count - sample frames per half-buffer (n-1). 
      HwRegRMW( ES1371_wDAC1IC_OFF, 0xffff, usInterruptCount ); 
//      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wDAC1IC_OFF), 
//                         (USHORT) (ulSamplesPerInt - 1) ) ; 
      break; 
 
    case ES1371_ADC : 
      // set the ADC DWORD frame count 
      HwPagedIOWrite( ES1371_ADCCTL_PAGE,  
                      ES1371_wADCFC_OFF,  
                      (ulDesiredBufferSize/4 - 1) & 0x0000ffff );   
 
      // Write ADC interrupt count - sample frames per half-buffer (n-1). 
      HwRegRMW( ES1371_wADCIC_OFF, 0xffff, usInterruptCount ); 
//      WRITE_PORT_USHORT((PUSHORT)(m_pPciAddr + ES1371_wADCIC_OFF), 
//                         (USHORT) (ulSamplesPerInt - 1) ) ; 
      break; 
  } 
  return ;   
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: StartDMAChannel 
// 
//  Description: Start a particular DMA channel running. 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to start 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::StartDMAChannel( UCHAR ucDMAChannel ) 
{ 
  UCHAR ucIOVal; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState ) 
      { 
        // modify pause bit for DAC0 
        ucIOVal = 0; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC0PAUSE, ucIOVal ); 
      } 
      else 
      { 
        // enable the DAC0 interrupt 
        ucIOVal = ES1371_SERCTL_DAC0IE; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC0IE, 
                  ucIOVal );  
 
        // start DAC0 
        ucIOVal = ES1371_DEVCTL_DAC0_EN; 
        HwRegRMW( ES1371_bDEVCTL_OFF, 
                  ES1371_DEVCTL_DAC0_EN, 
                  ucIOVal );  
      } 
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING; 
      break; 
 
    case ES1371_DAC1 : 
      if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState ) 
      { 
        // modify pause bit for DAC1 
        ucIOVal = 0; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC1PAUSE, ucIOVal ); 
      } 
      else 
      { 
        // enable the DAC1 interrupt 
        ucIOVal = ES1371_SERCTL_DAC1IE; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC1IE, 
                  ucIOVal );  
 
        // start DAC1 
        ucIOVal = ES1371_DEVCTL_DAC1_EN; 
        HwRegRMW( ES1371_bDEVCTL_OFF, 
                  ES1371_DEVCTL_DAC1_EN, 
                  ucIOVal );  
      } 
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING; 
      break; 
 
    case ES1371_ADC : 
      // enable the ADC interrupt 
      ucIOVal = ES1371_SERCTL_ADCIE; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_ADCIE, 
                ucIOVal );  
 
      // start ADC 
      ucIOVal = ES1371_DEVCTL_ADC_EN; 
      HwRegRMW( ES1371_bDEVCTL_OFF, 
                ES1371_DEVCTL_ADC_EN, 
                ucIOVal );  
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_RUNNING; 
      break; 
  } 
  return; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: StopDMAChannel 
// 
//  Description: Stop a particular DMA channel. 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to stop 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::StopDMAChannel( UCHAR ucDMAChannel ) 
{ 
  UCHAR ucIOVal; 
  ULONG ulFrameCount = 0; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // Stop DAC0 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bDEVCTL_OFF, 
                ES1371_DEVCTL_DAC0_EN, ucIOVal ); 
 
      // disable the DAC0 interrupt 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_DAC0IE, ucIOVal ); 
 
      if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState ) 
      { 
        // modify pause bit for DAC0 
        ucIOVal = 0; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC0PAUSE, ucIOVal ); 
      } 
 
      // Clear out the Current Frame count register 
      ulFrameCount = HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF);  
      HwPagedIOWrite( ES1371_DAC0CTL_PAGE,  
                      ES1371_wDAC0FC_OFF, 
                      ulFrameCount & 0x0000ffff );  
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED; 
      break; 
 
    case ES1371_DAC1 : 
      // Stop DAC1 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bDEVCTL_OFF, 
                ES1371_DEVCTL_DAC1_EN, ucIOVal); 
 
      // disable the DAC1 interrupt 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_DAC1IE, ucIOVal); 
 
      if ( DMA_PAUSED == m_dmachannel[ucDMAChannel].ulDMAChannelState ) 
      { 
        // modify pause bit for DAC0 
        ucIOVal = 0; 
        HwRegRMW( ES1371_bSERCTL_OFF, 
                  ES1371_SERCTL_DAC1PAUSE, ucIOVal ); 
      } 
 
      // Clear out the Current Frame count register 
      ulFrameCount = HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF);  
      HwPagedIOWrite( ES1371_DAC1CTL_PAGE,  
                      ES1371_wDAC1FC_OFF, 
                      ulFrameCount & 0x0000ffff );  
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED; 
      break; 
 
    case ES1371_ADC : 
      // Stop ADC 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bDEVCTL_OFF, 
                ES1371_DEVCTL_ADC_EN, ucIOVal); 
 
      // disable the ADC interrupt 
      ucIOVal = 0; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_ADCIE, ucIOVal); 
 
      // Clear out the Current Frame count register 
      ulFrameCount = HwPagedIORead( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF);  
      HwPagedIOWrite( ES1371_ADCCTL_PAGE,  
                      ES1371_wADCFC_OFF, 
                      ulFrameCount & 0x0000ffff );  
 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_STOPPED; 
      break; 
  } 
  return; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: PauseDMAChannel 
// 
//  Description: Pause a particular DMA channel. 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel to pause 
// 
//  Returns: none    
// 
//  Note: 
// 
//-------------------------------------------------------------------------- 
void 
CES1371::PauseDMAChannel( UCHAR ucDMAChannel ) 
{ 
  UCHAR ucIOVal; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // wait until interrupt count is non-zero 
//      while ( !HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0CIC_OFF));  
 
      // modify pause bit for DAC0 
      ucIOVal = ES1371_SERCTL_DAC0PAUSE; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_DAC0PAUSE, ucIOVal ); 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_PAUSED; 
      break; 
 
    case ES1371_DAC1 : 
      // wait until interrupt count is non-zero 
//      while ( !HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1CIC_OFF));  
 
      // modify pause bit for DAC1 
      ucIOVal = ES1371_SERCTL_DAC1PAUSE; 
      HwRegRMW( ES1371_bSERCTL_OFF, 
                ES1371_SERCTL_DAC1PAUSE, ucIOVal); 
      // save the state 
      m_dmachannel[ucDMAChannel].ulDMAChannelState = DMA_PAUSED; 
      break; 
 
    case ES1371_ADC : 
      break; 
  } 
  return; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: GetDMAPosition 
// 
//  Description: reads the current position of a DMA channel. 
// 
//  Parameters: UCHAR ucDMAChannel : Index of the DMA channel 
// 
//  Returns: ULONG current DMA position in bytes   
// 
//  Note: This function returns the DMA position NOT the sample play 
//        cursor.  It appears that this will be used for buffer filling. 
// 
//-------------------------------------------------------------------------- 
ULONG 
CES1371::GetDMAPosition( UCHAR ucDMAChannel ) 
{ 
  ULONG ulCurrentPos = 0; 
 
  switch ( ucDMAChannel ) 
  { 
    case ES1371_DAC0 : 
      // read the Frame register 
      ulCurrentPos = HwPagedIORead( ES1371_DAC0CTL_PAGE, ES1371_wDAC0FC_OFF);  
      // the current frame count is in the upper WORD 
      ulCurrentPos >>= 16; 
 
      // multiply the DWORD count by 4 to get a BYTE count to return 
      ulCurrentPos *= 4; 
      break; 
 
    case ES1371_DAC1 : 
      // read the Frame register 
      ulCurrentPos = HwPagedIORead( ES1371_DAC1CTL_PAGE, ES1371_wDAC1FC_OFF);  
      // the current frame count is in the upper WORD 
      ulCurrentPos >>= 16; 
 
      // multiply the DWORD count by 4 to get a BYTE count to return 
      ulCurrentPos *= 4; 
      break; 
 
    case ES1371_ADC : 
      // read the Frame register 
      ulCurrentPos = HwPagedIORead( ES1371_ADCCTL_PAGE, ES1371_wADCFC_OFF);  
      // the current frame count is in the upper WORD 
      ulCurrentPos >>= 16; 
 
      // multiply the DWORD count by 4 to get a BYTE count to return 
      ulCurrentPos *= 4; 
      break; 
  } 
  return ulCurrentPos; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: GetInterruptSource 
// 
//  Description: returns the source of the current interrupt 
// 
//  Parameters: none 
// 
//  Returns: UCHAR LONG current DMA position in bytes   
// 
//-------------------------------------------------------------------------- 
UCHAR 
CES1371::GetInterruptSource( void ) 
{ 
    ULONG intstat; 
    UCHAR intsrc; 
 
    intstat = READ_PORT_ULONG( (PULONG)(m_pPciAddr + ES1371_dSTATUS_OFF) );  
 
    // If we get all f's back we can't see the hardware 
    if ( 0xffffffff == intstat ) 
      return ES1371_INT_NONE; 
 
    if ( !( ES1371_INTSTAT_PENDING & intstat )) 
      return ES1371_INT_NONE; 
 
    intsrc = (UCHAR)(intstat) & ES1371_INT_MASK; 
 
    return intsrc; 
} 
 
//-------------------------------------------------------------------------- 
// 
//  Name: AckDMAInterrupt 
// 
//  Description: clean up a (set of) interrupt(s)  
// 
//  Parameters: UCHAR ucIntSrc : a bit mask interrupts to ack 
// 
//  Returns: none   
// 
//-------------------------------------------------------------------------- 
void 
CES1371::AckDMAInterrupt( UCHAR ucIntSrc ) 
{ 
    UCHAR ackmask = 0; 
 
    if ( ES1371_INT_ADC & ucIntSrc ) 
       ackmask |= ES1371_SERCTL_ADCIE ; 
 
    if ( ES1371_INT_DAC0 & ucIntSrc ) 
       ackmask |= ES1371_SERCTL_DAC0IE ; 
 
    if ( ES1371_INT_DAC1 & ucIntSrc ) 
       ackmask |= ES1371_SERCTL_DAC1IE ; 
 
    // now ack the interrupts - first set the IEs to 0 
    HwRegRMW( ES1371_bSERCTL_OFF, ackmask, 0x00); 
 
    // then set the IEs back to 1 
    HwRegRMW( ES1371_bSERCTL_OFF, ackmask, ackmask); 
} 
    
 
//-------------------------------------------------------------------------- 
// 
//  Name: JoystickEnable 
// 
//  Description: Enable or disable the joystick port IO range  
// 
//  Parameters:  
//     ULONG ulIOPort : The starting IO address to use or 0 to disable 
// 
//  Returns: none   
// 
//-------------------------------------------------------------------------- 
void 
CES1371::JoystickEnable( ULONG ulIOPort ) 
{ 
    UCHAR joyio = 0; 
 
    if ( ( 0x00000200 == ulIOPort ) || 
         ( 0x00000208 == ulIOPort ) || 
         ( 0x00000210 == ulIOPort ) || 
         ( 0x00000218 == ulIOPort ) ) 
    { 
         // move the two useful bits to the correct position 
         joyio = UCHAR( ulIOPort >> 3 ) ; 
 
         // set the two bits that control the joystick io range 
         HwRegRMW( ES1371_bJOYCTL_OFF, 0x03, joyio ); 
 
         // enable the joystick port 
         joyio = ES1371_DEVCTL_JSTICK_EN ; 
         HwRegRMW( ES1371_bDEVCTL_OFF, ES1371_DEVCTL_JSTICK_EN, joyio ); 
    } 
    else // disable 
    { 
         // disable the joystick port 
         joyio = 0; 
         HwRegRMW( ES1371_bDEVCTL_OFF, ES1371_DEVCTL_JSTICK_EN, joyio ); 
    }      
} 
    
 
/***************************************************************************** 
 * SynchronizedPagedIO() 
 ***************************************************************************** 
 * Do paged IO syncronized with the ISR. 
 */ 
NTSTATUS 
SynchronizedPagedIO 
( 
    IN      PINTERRUPTSYNC  InterruptSync, 
    IN      PVOID           syncIOContext 
) 
{ 
    PSYNCIOCONTEXT context; 
 
    context = (PSYNCIOCONTEXT)syncIOContext; 
    ASSERT(context->pHardware); 
    ASSERT(context->ulPage); 
    ASSERT(context->ulIOAddress); 
 
    NTSTATUS ntStatus = STATUS_SUCCESS; 
 
	// write the page register if needed 
    if ( context->pHardware->m_ulDRegs[ES1371_bMEMPAGE_OFF/4] != context->ulPage ) 
    { 
        WRITE_PORT_UCHAR(context->pHardware->m_pPciAddr + ES1371_bMEMPAGE_OFF,  
                         UCHAR(context->ulPage) & 0x0f ); 
        // save in the regs array 
        context->pHardware->m_ulDRegs[ES1371_bMEMPAGE_OFF/4] = context->ulPage; 
    } 
 
    // read or write the data 
    if ( context->fRead ) 
    { 
        *(context->pulData) =  
            READ_PORT_ULONG(  
               PULONG(context->pHardware->m_pPciAddr + context->ulIOAddress) ); 
    } 
    else // write 
    { 
        WRITE_PORT_ULONG(  
               PULONG(context->pHardware->m_pPciAddr + context->ulIOAddress), 
               *(context->pulData) ); 
    } 
 
    return ntStatus; 
} 
 
 


 
 